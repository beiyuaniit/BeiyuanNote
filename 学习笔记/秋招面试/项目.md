# ==商品抢购==

## 为什么要两次md5加密

- 加密方式
  - 客户端：PASS=MD5(明文+固定Salt)      不能看到明文信息直接输入框登录，保护密码的原始值
  - 服务端：PASS=MD5(用户输入+随机Salt)          第一次加密的密文没有被窃取，但是数据库被攻击了，攻击者难以通过hash碰撞来还原用户密码。
- why
  - 用户端MD5加密是为了防止用户密码在网络中明文传输，服务端MD5加密是为了提高密码安全性，双 重保险
- md5算法
  - MD5算法具有以下几个特点：
    1. 快速性：MD5算法的计算速度相对较快，适合在对性能有要求的场景中使用。
    2. 固定输出长度：无论输入数据的长度是多少，MD5算法始终会生成一个128位（16字节）的哈希值作为输出。这使得校验数据相对简单。
    3. 单向性：MD5算法是一种单向哈希函数，无法通过哈希值逆推出原始数据。这使得它在密码存储等场景中可以提供一定的安全性。
    4. 确定性：对于相同的输入数据，它会生成相同的输出
  - MD5算法也存在以下几个特点导致其安全性较弱：
    1. 碰撞概率较高：由于MD5算法的输出空间相对较小（只有128位），不同的输入可能会产生相同的哈希值。这意味着存在碰撞概率，即两个不同的数据产生相同的MD5哈希值。
    2. 易受暴力破解：随着计算能力的提高，恶意用户可以使用暴力破解等方式找到与给定MD5哈希值匹配的原始数据。这使得MD5算法在密码相关应用中不再安全。
    3. 弱防篡改性：由于MD5算法的输出固定，恶意用户可以通过替换输入数据中的某些部分来生成相同的MD5哈希值，从而破坏数据的完整性验证。
- 其他hash加密算法
  - SHA-2系列算法是MD5和SHA-1算法的后续版本，它们产生的哈希值长度更长，安全性更高
  - Blake2：Blake2是一种快速、安全的哈希算法，比MD5和SHA-2系列算法更快，并且具有较低的碰撞概率。

## 哨兵模式

- 垂直扩展，一主一从或者一主多从

- 应用场景

  - 哨兵模式适用于以下场景：

    1. Redis 高可用：哨兵模式最初是为了解决 Redis 的高可用性问题而引入的。在 Redis 主从复制的架构中，通过引入哨兵来监控和管理 Redis 实例，可以实现自动故障转移和故障恢复，提高 Redis 的可用性。
    2. 故障切换与故障恢复：哨兵模式可以将一个或多个哨兵进程配置在独立的服务器上，监控主节点和从节点的状态。当监测到主节点故障时，哨兵会自动进行故障切换，并将其中一个从节点提升为新的主节点，然后将原来的主节点切换为从节点，实现快速故障恢复。
    3. 高可用的分布式系统：哨兵模式不仅可以用于单个 Redis 实例的高可用，还可以在分布式系统中多个 Redis 实例的场景下应用。通过配置多个哨兵进程来监控和管理多个 Redis 实例，可以实现整个集群的高可用性，提供容错和自动故障转移机制。
    4. 动态扩展：在需要动态扩展 Redis 实例的情况下，可以使用哨兵模式来自动识别新添加的实例并将其添加到监控列表中。这样在有新实例加入或旧实例故障时，哨兵可以自动进行故障转移和配置更新，无需手动干预。
    5. 配置管理：哨兵模式还可以用于集中管理 Redis 配置，包括监控 Redis 实例的状态、参数配置的变更以及故障节点的恢复。这样可以降低配置管理的复杂性，避免手动配置的错误和不一致。

    需要注意的是，哨兵模式虽然提供了高可用性和自动故障转移的能力，但也会增加系统的复杂性和资源开销。在配置和使用哨兵模式时，应根据具体需求和可用资源进行权衡和调整。

- 原理

  - 哨兵模式是用于实现 Redis 高可用性的一种机制。它通过引入哨兵进程来监测和管理 Redis 实例，实现故障切换和自动故障恢复。以下是哨兵模式的基本工作原理：

    1. 哨兵选举：在哨兵模式中，有一个或多个哨兵进程负责监控 Redis 实例。哨兵之间通过互相发送心跳包来保持联络。当一个哨兵检测到主节点不可用时，它会向其他哨兵发起选举请求，通过投票选择一个新的主节点。
    2. 主节点监控：每个哨兵周期性地对 Redis 实例进行健康检查，包括检查 Redis 主节点和从节点的状态。它们通过发送 INFO、PING、SENTINEL is-master-down-by-addr 等命令来监测实例的可用性。如果哨兵发现主节点不可用，它会执行自动故障转移。
    3. 自动故障转移：一旦哨兵确认主节点不可用，它会从备选的从节点中选择一个成为新的主节点。在选举过程中，哨兵会考虑实例的优先级、复制偏移量、最近一次同步时间等因素。选举完成后，哨兵会将新的主节点信息广播给其他哨兵和客户端，进行相应的配置更新。
    4. 故障恢复：一旦新的主节点选出并配置更新完成，其他的从节点会重新连接到新的主节点并进行同步，以保持数据的一致性。同时，原来的主节点将会被切换为从节点，成为新主节点的从节点，从而实现故障恢复。
    5. 哨兵配置：哨兵的配置包括监控的 Redis 实例信息、故障切换策略、故障切换的最小投票数、故障切换超时时间等。通过配置这些参数，可以调整哨兵模式的行为和可靠性。

    总之，哨兵模式通过哨兵进程的监控和管理，实现了对 Redis 实例的故障切换和自动故障恢复。它能够提高系统的可用性，降低人工操作和维护的成本。在生产环境中，可以通过适当配置哨兵的数量和参数来提供高可用的 Redis 服务。

## 限流策略

- 用到的是固定窗口计数法吧

## 分布式锁

- 项目中没有用到吧
- 用的是lua脚本控制库存不会扣减到负数
  - 还是要脚本吧，毕竟扣了多少可以控制

## 数据库的瓶颈

- 将一条库存信息分为多行，并行去扣
  - 还不至于分库

# ==房源搜索==

## 为什么elasticsearch倒排索引建立后不支持修改

- Elasticsearch中的倒排索引是一种高效的数据结构，用于支持全文搜索和近实时的文档检索。倒排索引通过将文档中的每个词与其所在文档的关联关系进行索引，提供了快速的文本搜索和相关性排序。

  当索引被创建后，Elasticsearch会将文档的内容按照预定义的分词器（Tokenizer）进行分词，然后将每个词与文档的关联信息建立索引。这个过程是在索引创建时一次性进行的，并且是不可变的。

  由于倒排索引一旦建立，它的数据结构和关联信息将无法直接修改。这主要是由于以下几个原因：

  1. 数据结构复杂性：倒排索引是一种复杂的数据结构，需要在索引构建过程中建立关联信息和相关数据结构。如果允许修改索引后的关联信息，将导致整个数据结构的一致性受到破坏，搜索结果的准确性可能受到影响。
  2. 磁盘和性能影响：修改倒排索引需要对已存储的倒排数据进行实时修改或重建，这将对磁盘和性能产生重大的影响。尤其是当索引规模较大时，重新构建或修改索引可能需要较长的时间和更多的计算资源。

  虽然Elasticsearch不支持在倒排索引建立后直接修改，但提供了其他方式来更新索引中的文档：

  1. 更新（Update）API：可以使用Update API来部分更新文档。这个操作实际上是删除旧文档并添加新文档的过程，但是Elasticsearch会尽可能高效地执行这个操作，以最小化对索引的影响。
  2. 重新索引（Reindexing）：当需要修改索引的结构或数据时，可以通过重新索引来实现。重新索引可以将现有索引中的文档重新构建到新的索引中，以便进行结构调整、数据迁移或其他修改操作。

  总之，倒排索引在建立后是不可变的，这是为了保证索引的一致性和性能。对于需要修改索引数据的场景，可以使用更新API或重新索引等方法来实现所需的更改。

## 令牌桶和漏桶限流

- 讲的不错：https://www.cnblogs.com/kiko2014551511/p/16869723.html
- 两个都有桶，能够一定程度应对突发流量。不同的是漏桶是恒定速率，令牌桶的速率可以有波动
- 漏桶算法（Leaky Bucket）：（主要限定速率） 累加前面、当前秒请求
  - 漏桶算法将请求均匀地以恒定速率（一个请求一个请求）处理。
  - 桶中有一个固定容量的水（请求），并以固定速率漏水（处理请求）。
  - 当请求到达时，将被放入到漏桶中，如果漏桶已满，则请求将被拒绝。
  - 这种算法的特点是可以平滑处理请求，有固定的处理速率，对于平稳的流量有较好的效果，但对突发流量的处理能力相对较弱。
- 令牌桶算法的基本原理如下：（拿到令牌就处理，主要限定上限） 桶容量一般比生成速度大吧   比如可以累加前几秒的令牌
  - 令牌桶中以固定速率（比如每秒生成一定数量的令牌）生成令牌，并将令牌存放在桶中。
  - 当请求到达时，需要从令牌桶中获取一个令牌，如果桶中有足够的令牌，则允许请求通过，并从桶中取走一个令牌。
  - 如果桶中没有足够的令牌，则请求将被限制，直到令牌桶中有足够的令牌供请求获取。

## 固定窗口和滑动窗口限流

- 不能够累计请求，若当前的计数用完，且请求都处理完了，但是这时候有新的请求进来，会被丢弃
- 固定窗口记数法（Fixed Window Counting）：（窗口不为0就处理，和令牌桶有点类似）没有等待队列   前面的不能累加 一秒内用完就没有了
  - 固定窗口记数法将时间划分为固定大小的窗口，每个窗口内有一个计数器用来记录请求的数量。
  - 在每个窗口结束时，计数器会被重置为零，新窗口开始计数。
  - 当请求到达时，会将请求计数到当前窗口内，如果当前窗口内的请求数超过预设的限制阈值，请求将被拒绝。
  - 这种算法的特点是对突发流量不敏感，窗口的大小决定了能承受的峰值流量，但存在较大延迟和浪费资源的问题。
  - **优点**
    - 窗口是时间框，可以灵活控制每个时间段允许多少请求
    - 窗口有时间和容量维度
- 滑动窗口记数法的基本原理如下：
  1. 将时间划分为固定大小的窗口，每个窗口内有一个计数器用来记录请求的数量。
  2. 对于每次请求到达时，将请求计数到当前窗口内，并检查当前窗口内的请求数是否超过预设的限制阈值。
  3. 窗口会根据设定的滑动间隔（例如每秒钟滑动一次）进行滑动，旧的窗口会被移除，新的窗口会被创建。
  4. 在滑动过程中，如果滑动窗口内的总请求数超过限制阈值，则请求将被拒绝。
  5. 比固定窗口的好处是，更精细地对请求进行控制，并且对突发流量的敏感性相对较高。通过滑动窗口的方式，算法可以及时地感知到请求的变化，并进行动态调整，以更好地限制请求的处理速度。