# ==内存结构==

## JVM

- 定义

  - Java Virtual Machine，JAVA程序的运行环境（JAVA二进制字节码的运行环境）

- 好处
  - 一次编写，到处运行。屏蔽了字节码和底层操作系统的差异，对外提供了一致的运行环境，达到平台无关性
  - 自动内存管理，垃圾回收机制
  - 数组下标越界检查

- 比较

  JVM JRE JDK的区别

  [![img](https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150422.png)](https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150422.png)

## JVM 指令

* jps
  * 显式虚拟机进程
* jstat
  * 监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。
* jmap
  * 查看堆快照，内存信息，可生成dump文件
* jhat
  * 分析堆快照
* jstack
  * 查看线程堆栈信息
* jconsole
  - 可视化的管理控制台

## 内存模型

- 分类

  - 线程共享
    - 方法区（类），堆（对象），直接内存
  - 线程私有
    - 程序计数器，虚拟机栈，本地方法栈        

- 程序计数器（线程私有）
  
  - 用于保存线程下一条所要执行的指令的地址
  - 是一个寄存器，速度快，不会内存溢出
  
- 虚拟机栈（线程私有）
  - 每个方法在执行的时候就会创建一个栈帧
  - 用于存储局部变量表(基本数据类型和对象的引用)、操作数、动态链接和方法返回等信息
  - 栈由多个栈帧组成，内存不够时抛出stackOverflowError 异常
  - 每个线程只能有一个活动栈帧（正在执行的方法），多个栈帧存在，则递归执行
  - 栈的演示:idea中Debug模式下的Frames显示的是当前栈帧
  - GC不涉及栈
  - 方法内（栈帧内）声明的局部变量相对独立，但若返回了局部对象的引用，还是可能导致被其他线程修改。因此是相对独立
  
- 本地方法栈（线程私有
  
  - 保存的是native方法的，来与操作系统底层交互
  - 在计算机编程中，"native方法"是指在程序中调用的由底层系统或外部库提供的特定功能的方法。这些方法由编译为机器码的本地代码实现，与高级编程语言（如Java、C++等）的代码相区别。当在程序中调用native方法时，程序会将执行控制权转交给底层系统或外部库，以进行特定操作或访问底层资源。
  - Native方法通常用于与硬件交互、访问底层系统功能或使用底层库（例如图形渲染、网络通信等）。通过使用native方法，开发者可以借助底层的性能优势和特定功能，从而在高级语言中获得更加灵活和强大的功能。
  
- 堆（线程共享
  
  - 对象在堆上分配内存，涉及垃圾回收
  - 1.8的字符串常量池还是在堆中
  
- 方法区（线程共享
  
  - 存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据
  
- 直接内存（不在JVM）
  - 属于操作系统，常见于NIO操作时，**用于数据缓冲区**
  
  - 直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。
  
  - 分配回收成本较高，但读写性能高
  
  - 不受JVM内存回收管理
  
  - 直接内存（Direct Memory）的性能较高主要有以下几个原因：
  
    1. 无需数据拷贝：直接内存是通过操作系统提供的函数将数据直接从磁盘或网络等设备上加载到内存中，而无需经过额外的数据拷贝操作。这避免了数据复制带来的额外开销，提高了性能。
    2. 避免了垃圾回收（Garbage Collection）开销：在使用直接内存时，内存的分配和释放不受垃圾回收器的管理。相比于在堆上分配和释放内存，直接内存的分配和释放操作更加简单和高效，减少了垃圾回收带来的性能影响。
    3. 避免了内存压缩和内存碎片问题：直接内存不受Java堆内存大小的限制，因此可以避免内存压缩和内存碎片问题。内存压缩会导致额外的CPU开销，而内存碎片会影响内存的利用效率，而直接内存的使用可以降低或避免这些问题。
    4. 提供了快速的IO操作：直接内存可以通过操作系统提供的函数进行直接的数据读写操作，而无需通过Java的IO流进行数据传输。这种直接的数据读写操作显著减少了数据传输的开销，提高了IO的速度。
  
    需要注意的是，直接内存的使用也需要慎重考虑。过度使用直接内存可能会有一定的风险，比如潜在的内存泄漏问题和操作系统资源的限制。因此，在使用直接内存时，需要仔细评估实际需求和系统性能，并根据具体情况进行权衡和选择。

## 对象及其引用

- 对象
  - 无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中
- 引用
  - 引用类型的引用和基本类型的值存储的地方相同。
  - 当变量为**局部变量**时，引用类型的引用和基本类型的值存储在**栈内存**中。
  - 当变量为**成员变量**时，引用类型的引用和基本类型的值存储在**堆内存**中。
  - 当变量为**静态变量**时，引用类型的引用和基本类型的值存储在**方法区**中。

## heap 和stack 

- 堆和栈

  - 栈保存局部变量等线程信息
  - 对象在堆上分配内存，涉及垃圾回收

- 申请方式
  - stack:由系统自动分配。例如，声明在函数中一个局部变量 int b; 系统自动在栈中为 b 开辟空间
  - heap:需要程序员自己申请，并指明大小，在 c 中 malloc 函数，对于Java 需要手动 new Object()的形式开辟

- 申请后系统的响应
  - stack：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
  - heap：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

- 申请大小的限
  - stack：栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是 2M（默认值也取决于虚拟内存的大小），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。
  - heap：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的， 自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见， 堆获得的空间比较灵活，也比较大。

- 申请效率的比较
  - stack：由系统自动分配，速度较快。但程序员是无法控制的。
  - heap：由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。

- heap和stack中的存储内容

  - stack：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址， 然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。

    当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
    
  - heap：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

## java的堆和栈区别

- 在Java中，堆（Heap）和栈（Stack）是两个重要的内存区域，用于存储不同类型的数据。它们在内存管理、分配方式和生命周期等方面存在一些关键的区别。

  1. 分配方式：堆用于存储对象实例和数组等动态创建的数据，由Java垃圾回收器负责管理分配和释放。栈用于存储局部变量、方法参数和方法调用等，在方法调用时分配，在方法返回时自动释放。
  2. 内存空间：堆的大小一般是事先定义好的，可以根据需要动态调整。栈的大小是固定的，由Java虚拟机在启动时设定，并且栈的容量往往较小。
  3. 数据存储：堆存储的是对象实例，包括对象的成员变量和对象头信息等。栈存储的是基本类型变量和对象的引用，即局部变量和方法参数。
  4. 生命周期：堆中的对象的生命周期由程序员手动控制，可以在任何时刻创建和销毁对象。栈中的变量的生命周期与方法调用关联，当方法执行结束时，栈帧会被销毁，其中的局部变量也会被自动释放。
  5. 内存管理：堆由垃圾回收器自动管理，负责回收不再被引用的对象，释放内存空间。栈的内存管理是自动的，由Java虚拟机在方法调用和返回时管理。
  6. 并发性：堆可以被多个线程共享，因此需要采取同步机制来处理多线程访问的竞争。栈是线程私有的，每个线程都有自己独立的栈空间，不需要考虑线程间的竞争问题。

  在实际编程中，堆和栈的使用方式和目的不同。堆适合存储大量动态创建的对象，而栈适合存储局部变量和方法调用信息等临时数据。

  总结起来，堆和栈在内存管理、分配方式、数据存储、生命周期和并发性等方面存在明显的区别。了解并掌握它们的特点对于编写高效、健壮的Java程序是很重要的。

## 内存溢出

- 除了程序计数器，其他内存区域都有内存溢出 的风险。
  - 栈
    - 一般经常会发生 StackOverflowError，比如 32 位的 windows 系统单进程限制 2G 内存，无限创建线程就会发生栈的 OOM
  - 堆
    - 溢出会出 java.lang.OutOfMemoryError: Java heap space，设置最大元空间大小参数无效；
    - GC 之后无法在堆中申请内存创建对象就会报错；
  - 方法区 
    - 经常会遇到的是动态生成大量的类、jsp 等；
  - 直接内存 
    - 涉及到 -XX:MaxDirectMemorySize 参数和 Unsafe 对象对内存的申请。

- 排查 OOM 的方法：
  - 增加两个参数 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录；
  - 同时 jstat 查看监控 JVM 的内存和 GC 情况，先观察问题大概出在什么区域；
  - 使用 MAT 工具载入到 dump 文件，分析大对象的占用情况，比如 HashMap 做缓存未清理，时间长了就会内存溢出，可以把改为弱引用 。

##  常量池

* 概念
  * 在大部分的Java虚拟机实现中，常量池（Constant Pool）是方法区（Method Area）的一部分，而不是堆区（Heap）。以前放在永久代，后来放在元空间？
  * 常量池是用于存放编译期生成的各种字面量和符号引用的一部分内存，包括字符串、整数、浮点数、类和接口的全限定名、字段和方法的名称和描述符等信息。
  * 常量池的内容在类加载时被加载到方法区中，并在运行时被使用，供Java程序在运行过程中进行常量的引用和访问。常量池是每个类都拥有独立的，它保存了类级别的常量，而不是对象级别的常量。
  * 需要注意的是，尽管常量池的内容位于方法区中，但常量本身并不是方法区的一部分。常量池中的字面量被加载到方法区中，但引用这些字面量的对象本身，则是存储在堆中的。
  * 综上所述，在Java虚拟机中，常量池通常隶属于方法区，用于存储各种字面量和符号引用。堆区则是用于存储对象实例和数组等动态分配的数据。
* **Class文件常量池**
  * class文件是一组以字节为单位的二进制数据流，在java代码的编译期间，我们编写的java文件就被编译为.class文件格式的二进制数据存放在磁盘中，其中就包括class文件常量池。
  * 字节码文件
* **运行时常量池**：
  * 运行时常量池相对于class常量池一大特征就是具有动态性，java规范并不要求常量只能在运行时才产生，也就是说运行时常量池的内容并不全部来自class常量池，在运行时可以通过代码生成常量并将其放入运行时常量池中，这种特性被用的最多的就是String.intern()。
  * String.intern()运行时产生
* **全局字符串常量池**：
  * 字符串常量池是JVM所维护的一个字符串实例的引用表，在HotSpot VM中，它是一个叫做StringTable的全局表。在字符串常量池中维护的是字符串实例的引用，底层C++实现就是一个Hashtable。这些被维护的引用所指的字符串实例，被称作”被驻留的字符串”或”interned string”或通常所说的”进入了字符串常量池的字符串”。 
  * StringTable缓存字符串
* **基本类型包装类对象常量池**：
  * java中基本类型的包装类的大部分都实现了常量池技术，这些类是Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。另外上面这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。
  * 缓存了【-129-127】之间的数据

## 常见JVM参数

- 当涉及到JVM参数时，确实有很多可用的选项。以下是一些常用的JVM参数及其功能的详细介绍：

  1. -Xms<size>：设置Java堆的初始内存大小。示例：-Xms512m（初始堆大小为512兆字节）。此参数指定了在JVM启动时分配给Java堆的内存量。
  2. -Xmx<size>：设置Java堆的最大内存大小。示例：-Xmx1024m（最大堆大小为1024兆字节）。此参数指定了Java堆允许占用的最大内存量。超过此阈值，将会触发内存溢出错误。
  3. -Xss<size>：设置每个线程的堆栈大小。示例：-Xss256k（每个线程堆栈大小为256千字节）。此参数控制了线程创建时分配的堆栈内存大小。较大的堆栈大小可以支持更深的方法调用层次，但也会消耗更多的内存。
  4. -XX:PermSize=<size>（仅适用于Java 8之前）：设置永久代（PermGen）的初始内存大小。示例：-XX:PermSize=128m（初始永久代大小为128兆字节）。永久代存储了类的元数据、常量池和静态变量等信息。
  5. -XX:MaxPermSize=<size>（仅适用于Java 8之前）：设置永久代的最大内存大小。示例：-XX:MaxPermSize=256m（最大永久代大小为256兆字节）。超过此阈值，将会触发永久代溢出错误。
  6. -XX:MetaspaceSize=<size>（Java 8及以后）：设置元空间（Metaspace）的初始大小。示例：-XX:MetaspaceSize=256m（初始元空间大小为256兆字节）。元空间存储了类的元数据和方法区。
  7. -XX:MaxMetaspaceSize=<size>（Java 8及以后）：设置元空间的最大大小。示例：-XX:MaxMetaspaceSize=512m（最大元空间大小为512兆字节）。超过此阈值，将会触发元空间溢出错误。
  8. -Xmn<size>：设置年轻代的大小。示例：-Xmn256m（年轻代大小为256兆字节）。年轻代是Java堆的一部分，用于存放新创建的对象，它分为Eden区、Survivor区（From和To区）。
  9. -XX:SurvivorRatio=<ratio>：设置Eden区与Survivor区大小的比例。示例：-XX:SurvivorRatio=8（Eden区与Survivor区的比例为8:1）。此参数用于控制对象在年轻代中的分配策略。
  10. -XX:NewRatio=<ratio>：设置年轻代与老年代大小的比例。示例：-XX:NewRatio=2（年轻代与老年代的比例为1:2）。此参数用于调整Java堆中年轻代和老年代的大小关系。
  11. -XX:+UseParallelGC：启用并行垃圾收集器。此参数使用多线程进行垃圾收集，可以提供较高的吞吐量。
  12. -XX:+UseConcMarkSweepGC：启用并发标记清除垃圾收集器。此参数使用多线程进行垃圾收集，尽可能减少应用程序的暂停时间。
  13. -XX:+UseG1GC：启用G1垃圾收集器。此参数使用了G1（Garbage-First）算法，适用于具有大内存和多处理器的系统。
  14. -XX:ParallelGCThreads=<num>：设置并行垃圾收集的线程数。示例：-XX:ParallelGCThreads=4（并行垃圾收集的线程数为4）。此参数用于控制并行垃圾收集器使用的线程数量。
  15. -XX:MaxGCPauseMillis=<time>：设置垃圾收集的最大停顿时间目标。示例：-XX:MaxGCPauseMillis=100（最大垃圾收集停顿时间为100毫秒）。此参数指定了垃圾收集器在执行时尽量控制暂停时间不超过指定的毫秒数。

  这仅是一些JVM参数的例子，还有许多其他参数可用于微调和优化Java虚拟机的性能和行为。具体的参数选择应根据应用程序的需求、硬件环境和实际性能测试来确定。

# ==GC==

## 判断对象可回收

- 引用计数法

  - 某对象没有被引用时可回收

  - 缺点：无法回收循环引用的对象

- 可达性分析算法
  - JVM中的垃圾回收器通过**可达性分析**来探索所有存活的对象
  
  - 扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果**找不到，则表示可以回收**
  
  - 可以作为GC Root的对象（不认为需要回收的对象
    - 虚拟机栈（栈帧中的本地变量表）中引用的对象。　
    - 方法区中类静态属性引用的对象
    - 方法区中常量引用的对象
    - 本地方法栈中JNI（即一般说的Native方法）引用的对象
    
  - 对于循环引用，尽管这些对象之间相互引用，但如果这些对象与根对象之间不存在可达路径，那么它们被视为不可达的垃圾，可以被垃圾回收器回收。
  
  - 什么对象可以作为GC Root对象
  
    - 在Java中，以下对象可以作为GC Root对象:
  
      1. 虚拟机栈（Java栈帧）中引用的对象: 例如，方法中的本地变量和参数引用的对象。
      2. 静态变量引用的对象: 在类的静态变量中引用的对象，因为静态变量是直接存储在方法区中的。
      3. 方法区中常量引用的对象: 例如，字符串常量池中的字符串对象。
      4. JNI（Java Native Interface）引用的对象: 通过JNI方法从本地代码中引用的Java对象。
      5. 被同步锁（synchronized）持有的对象: 同步块中引用的对象，例如，线程持有的同步锁引用的对象。
      6. Java虚拟机自身引用的对象: 例如，虚拟机内部的对象或类引用。
  
      这些对象被认为是GC Root对象，因为它们是直接或间接地与程序执行相关联的，它们的引用链可以追溯到程序的起点，作为初始的可达性点。
  
      垃圾收集器通过遍历从这些GC Root对象开始的引用链，找出所有可以被访问到的对象，然后将不可达的对象标记为垃圾，并进行回收释放内存。

## JNI与native方法

- JNI

  - JNI（Java Native Interface）是Java提供的一种机制，用于在Java虚拟机（JVM）中与本地代码进行交互和调用。

    Java是一种跨平台的编程语言，但有时候需要与特定的本地库或操作系统进行交互。这些本地代码通常用C、C++等语言编写而成，无法直接在Java中调用。

    JNI提供了一套标准的接口和规范，允许Java程序通过特定的语法和函数调用来与本地代码进行通信。通过JNI，Java程序可以调用本地方法，也可以将Java类型转换为本地类型，并在Java和本地代码之间传递参数和数据。

    JNI的主要特点和用途包括：

    1. 提供了一种机制，使Java程序能够调用本地库或操作系统提供的功能。
    2. 允许Java程序与本地代码之间进行双向通信。
    3. 支持Java类型和本地类型之间的相互转换。
    4. 允许Java程序通过本地方法来处理底层资源（如文件、网络连接等）。

    在使用JNI时，需要编写本地方法接口（Native Method Interface），在接口中声明本地方法的签名，然后使用本地编译器将Java源代码和本地代码进行链接。

    尽管JNI提供了与本地代码交互的能力，但在使用时需要注意安全性和跨平台性，确保本地代码的正确性和可移植性。同时，使用JNI也需要遵循一定的规范和编程模式，以确保良好的代码质量和性能。

- native方法

  - 是的，与JNI相关的是Java中使用`native`关键字修饰的方法。当在Java中声明一个方法时，使用`native`关键字修饰的方法表示它是一个本地方法，即该方法的具体实现由外部的本地代码提供。

    `native`修饰符告诉编译器该方法的实现是在其他语言中编写的，并且可以通过JNI与Java进行交互。这样的方法在Java中只有方法的定义，而实际的实现代码位于本地代码中。

    使用`native`修饰方法的主要目的是在Java程序中调用本地库或操作系统提供的功能，或处理一些特定的底层资源。这样可以充分利用本地代码的优势，以提高性能、访问底层资源或与特定的硬件设备进行通信。

    在使用`native`修饰的方法时，需要按照JNI的规范编写本地方法接口，并使用本地编译器将Java代码和本地代码进行连接。通过JNI，Java程序可以调用本地方法，并将Java数据类型转换为本地数据类型，从而实现与本地代码的交互。

    需要注意的是，使用`native`修饰的方法要谨慎使用，因为它会导致Java程序与本地代码的耦合度增加，并且在跨平台性方面可能会受到一定的限制。必须确保本地代码的安全性、正确性和可移植性，并且需要在编写和使用本地代码时遵循相应的规范和最佳实践。

## 四种引用

[![img](https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png)](https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png)

- 强引用
  - 如new出来的对象
  - 只有GC Root**都不引用**该对象时，才会回收**强引用**对象
- 软引用
  - 当GC Root指向软引用对象时，在**内存不足时**，会**回收软引用所引用的对象**
- 弱引用
  - 在垃圾回收时，**无论内存是否充足**，都会回收弱引用所引用的对象
- 虚引用
  - 虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法
    - 主要用来跟踪对象被垃圾回收的活动

## 什么时候发生Full GC

- Full GC（Full Garbage Collection）是指对整个Java堆（包括新生代和老年代）进行一次完整的垃圾回收。与部分垃圾回收（Partial GC）不同，Full GC会暂停应用程序的执行，并对整个堆进行扫描和回收。

  Full GC通常在以下情况下发生：

  1. 遇到新生代对象无法放入Eden或Survivor空间：当新创建的对象无法放入Eden区，或者在Minor GC过程中对象无法晋升到老年代时，可能会触发Full GC。
  2. 老年代空间不足：当老年代中的对象占用达到一定阈值时，可能会触发Full GC。这是为了尽可能释放老年代中不再被引用的对象，以确保有足够的空间来存储新的对象。
  3. 显式调用System.gc()方法：虽然调用System.gc()方法并不保证会立即触发Full GC，但它会增加Full GC发生的机会，因为垃圾回收器可能会在该方法调用的时候启动Full GC。
4. MinorGC和marjorGC频繁发生？所以是先进行评估？

Full GC的发生会导致较长的停顿时间，因为要对整个堆进行扫描和回收，并且涉及到更复杂的对象标记和清理过程。因此，Full GC会对应用程序的性能和响应时间产生较大的影响。

  为了优化应用程序的性能，尽量减少Full GC的发生是一个重要的目标。可以通过调整堆的大小、合理设置新生代和老年代的比例、优化对象的生命周期管理等方式来降低Full GC的频率和影响。

## 新生代为什么要分Eden或Survivor

- 新生代为了提高垃圾回收的效率和减少垃圾回收的停顿时间，采用了Eden区和Survivor区的分代划分。

  Eden区是新对象分配的初始区域，当Eden区满时发生Minor GC（新生代垃圾回收），将Eden区中的存活对象复制到Survivor区，并同时清理掉不再存活的对象。经过多次Minor GC后仍然存活的对象会被晋升到老年代。

  为什么不仅仅使用Survivor区而将新生代分为Eden和Survivor呢？主要有以下几个原因：

  1. 对象存活率的考虑：通常情况下，新生成的对象中有很大一部分会很快变为垃圾，只有少部分对象会长时间存活。将新对象和存活对象分开，可以更高效地对其中的垃圾进行回收。如果只有Survivor区，那么存活对象和新对象会混在一起，垃圾回收的效率会降低。
  2. 复制算法的优势：Survivor区采用的是复制算法，即将存活的对象复制到另一个Survivor区，清理掉不再存活的对象。这种算法的特点是简单高效，只需要根据对象是否存活进行内存复制即可。相比之下，如果只有Survivor区，那么需要引入更复杂的回收算法，可能会导致垃圾回收的效率降低。
  3. 空间利用率的平衡：通过将新生代划分为Eden和Survivor，可以根据不同对象的存活情况进行合理的分配。Eden区作为初始区域，可以容纳新生成的对象；而Survivor区则用来存放在多次垃圾回收中仍然存活的对象。这样可以平衡各区域的空间利用率，提高整体的内存利用效率。

  综上所述，新生代分为Eden和Survivor两部分是为了更高效地进行垃圾回收和内存分配，并能更好地平衡空间利用率和对象存活率。只有Survivor区无法满足对垃圾回收效率和空间利用的需求。

- 只有Survivor不行吗

  - Survivor中的From和To是会发生清除、整理的

## 对象什么时候回收

- 在Java中，对象的回收（垃圾回收）是由Java垃圾回收器负责的，它会自动判断哪些对象是不再被引用的，并回收它们所占用的内存空间。

- 垃圾回收器运行：当Java虚拟机的垃圾回收器运行时，会扫描堆中的对象，并标记出所有可达的对象。那些没有被标记的对象就会被视为不可达，可以被回收。对象可以在满足以下条件时被回收

  1. 对象不可达：当一个对象不再被任何引用变量所引用时，称为对象不可达。垃圾回收器会通过可达性分析（Reachability Analysis）来确定对象是否可达。如果一个对象不可达，即无法通过任何引用链访问到该对象，那么它就可以被回收。
  2. 引用变量被重新赋值：如果一个对象的所有引用变量都被赋值为null或被其他对象引用覆盖，也会使该对象不可达，从而可以被回收。
  3. 引用超出作用域：当一个对象的引用变量超出了作用域（比如方法执行结束），该引用变量所引用的对象也会变为不可达，可以被回收。

  需要注意的是，对象的回收是非确定性的，垃圾回收的具体时机和策略是由虚拟机控制的。垃圾回收器的工作是在合适的时机自动触发的，它根据具体的算法和策略来进行垃圾的识别和回收。并不是每个不可达的对象一定会立即被回收，而是在垃圾回收器运行时才会进行回收处理。

  总之，对象可以在对象不可达、引用被重新赋值、引用超出作用域和垃圾回收器运行时被回收。垃圾回收器会自动回收这些不再使用的对象，释放它们所占用的内存空间，以便于程序继续创建和使用新的对象。

## 循环引用

- 针对循环引用问题，一些现代的垃圾回收器采用了更复杂的机制来解决。其中一种常见的处理方式是结合引用计数和可达性分析算法。通过引用计数算法追踪对象的引用数量，并在计数器为0时确定对象不再被引用。然后，在可达性分析的过程中，对于那些计数器为0的对象，进一步检查它们的引用是否形成循环引用，如果是，则将其标记为垃圾对象。
- 此外，还有其他高级的技术和机制，如根节点压缩、强/软/弱/虚引用、引用队列等，可以帮助垃圾回收器解决循环引用的问题。这些技术和机制可以辅助垃圾回收器判断对象是否为垃圾，即使存在循环引用的情况下也能进行准确的回收。
  - 显式断开循环引用：在循环引用的对象中，通过手动将引用置为空来打破循环引用。这意味着需要在适当的时候，主动检测并断开相关的引用。这种方法需要开发者明确了解对象之间的引用关系，并主动管理引用的创建和释放。
  - 软引用（Soft Reference）：软引用是弱引用的一种变种，更加灵活。当内存不足时，垃圾回收器可以根据需要回收软引用引用的对象，但并不强制要求回收。软引用通常用于构建缓存或者临时存储数据的场景，可以在内存紧张时释放一些缓存对象。
  - 弱引用（Weak Reference）：使用弱引用可以解决循环引用问题。弱引用是指一种不会阻止被引用对象被垃圾回收的引用。当只有弱引用指向一个对象时，即使该对象仍然被其他对象引用，仍然可以被回收。通过使用弱引用，可以避免循环引用造成的内存泄漏问题。
  - 虚引用（Phantom Reference）：虚引用是一种对对象的弱引用，它在任何时候都可能被垃圾回收器回收，且无法通过虚引用访问对象。虚引用通常与引用队列（Reference Queue）结合使用，可以在对象被回收前接收到通知。通过使用虚引用，可以将对象的回收操作与其他一些操作解耦，提供更灵活的控制。
- 怎么判断循环引用
  - 快慢指针
  - 怎么证明快慢指针有环一定会相遇？
    - 慢指针进入环后，两指针每移动一步，距离减一

## 垃圾回收算法

- 标记-清除

  - 先标记可回收对象的内存空间，后清除
  - 并不是将内存空间的字节清0，而是记录下地址，下次分配时直接覆盖

  - 不足
    - 容易产生内存碎片

- 标记-整理

  - 先标记，后整理（压缩）到连续的内存空间。两个幸存区From和To，解决内存碎片化
  - 缺点：需要额外的空间，且复制时消耗更多时间

  


## 分代回收

[![img](https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png)](https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png)

- 分代是针对不同生命周期的对象作不同的处理，生命周期长的减少GC次数

- 流程
  - 新创建的对象
    - 都被放在了新生代的伊甸园
  - 伊甸园空间不足
    - 进行Minor GC : 将伊甸园和幸存区FROM存活的对象先复制到 幸存区 TO中， 并让其寿命加1，再交换两个幸存区
    - 存区中的对象的寿命超过某个阈值（最大为15，4bit），就会被放入老年代中
  - 新生代、老年代空间不足
    - 会先触发Minor GC，再触发Full GC，扫描新生代和老年代中所有不再使用的对象并回收（比较费时）
  
- 其他
  - 大对象处理（超过）
    - 直接晋升老年代
  
- 针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：

  部分收集 (Partial GC)：

  - 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
  - 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
  - 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

  整堆收集 (Full GC)：收集整个 Java 堆和方法区。

## 垃圾回收器

- 概念
  - **并行收集**：指多条垃圾收集线程并行工作，用户线程阻塞
  - **并发收集**：指用户线程与垃圾收集线程同时工作，可交替执行
  - **吞吐量**：吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )

- 串行GC处理器
  - 特点
    - 只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入阻塞态
  - Serial 收集器
    - 最基本的、发展历史最悠久的收集器
    - 特点：**单线程、简单高效（与其他收集器的单线程相比），采用**复制算法**。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）
  - ParNew 收集器
    - ParNew收集器其实就是Serial收集器的多线程版本
    - **特点**：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题
  - Serial Old 收集器
    - Serial Old是Serial收集器的老年代版本
    - **特点**：同样是单线程收集器，采用**标记-整理算法**

- 吞吐量优先
  - 特点
    - 多线程
    - 堆内存较大，多核CPU
    - 单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短
    - **JDK1.8默认使用**的垃圾回收器

  - Parallel Scavenge 收集器
    - 与吞吐量关系密切，故也称为吞吐量优先收集器
    - **特点**：属于新生代收集器也是采用**复制算法**的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）
  - **Parallel Old 收集器**
    - Parallel Scavenge收集器的老年代版本
    - **特点**：多线程，采用**标记-整理算法**（老年代没有幸存区）

- 响应时间优先

  - 特点
    - 多线程
    - 堆内存较大，多核CPU
    - 尽可能让单次STW时间变短（尽量不影响其他线程运行）

  - CMS 收集器
    - Concurrent Mark Sweep，一种以获取**最短回收停顿时间**为目标的**老年代**收集器
    - **特点**：基于**标记-清除算法**实现。并发收集、低停顿，但是会产生内存碎片
    - **应用场景**：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务
    - **CMS收集器的运行过程分为下列4步：**
      - **初始标记**：标记GC Roots能直接到的对象。速度很快但是**仍存在Stop The World问题**
      - *并发标记**：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行**
      - 重新标记**：为了**修正并发标记期间**因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题**
      - 并发清除**：对标记的对象进行清除回收

- 吞吐量和响应时间兼顾
  - G1
    - Garbage First，JDK 9以后默认使用，而且替代了CMS 收集器
  - 特点
    - 同时注重吞吐量和低延迟（响应时间）
    - 超大堆内存（内存大的），会将堆内存划分为多个**大小相等**的区域
    - 整体上是**标记-整理**算法，两个区域之间是**复制**算法

- **分区算法region**

  分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间

- Full GC

  G1在老年代内存不足时（老年代所占内存超过阈值）

  - 如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理
  - 如果垃圾产生速度快于垃圾回收速度，便会触发Full GC

## 三色标记

- 标记 - 清除 法，
  - 这个标记会根据这个对象是否可达（GC Roots）来进行一个标记设置，GC 回收的时候就会根据这个标记进行清除。
  - 标记 - 清除 法最大的问题就是在清除的-时候需要 STW 这就导致了 GC 的效率就比较低。

- 三色标记
  - 三色标记最大的好处就是可以与业务线程并发执行，从而显著的提升标记的效率，三色 对应黑、白、灰三种颜色，每种颜色都代表着不同的意思
  - 三色
    - **黑色**：根对象或它所有的子对象都以及被扫描过。
    -  **灰色**：本身被扫描但是它的子对象还没被扫描完。
    -  **白色**：没有被扫描过的对象，如果扫描标记完成后还是白色的说明这个对象是垃圾。

- 并发带来问题
  - 因为在标记的时候业务线程还在继续运行，那么就会存在当 GC 其中一条线程以及完成标记扫描后与其他一条线程未被扫描完成后的对象发生了引用的改变。
  - 处理 
    - CMS 是重新扫描所有的对象
    -  G1 则是以修改的引用作为根进行扫描   （效率更高

## 跨代引用

- 跨代引用 一般指的是老年代的对象中引用了新生代的对象，如果新生代发生 Young GC 的时候就需要扫从老年代到新生代的所有引用，这样的扫描就比较消耗性能，所以就存在了Card Table（卡表） 和 Rset（记忆集）。

- CardTable
  - 类似于一个数组，元素对应了每个内存区域。
  - 发生跨代引用则标记为1，并放一个RSet

- RSet
  - 存放某个内存区域的跨代引用，GC时扫描这里就行了



## GC 调优

- 调优领域
  - 内存
  - 锁竞争
  - CPU占用
  - IO
  - GC

- 选择合适的GC
  - CMS G1 ZGC
  - ParallelGC
  - Zing

- 最快的GC是不发生GC
  - 首先排除减少因为自身编写的代码而引发的内存问题
  - 查看Full GC前后的内存占用，考虑以下几个问题
    - 数据是不是太多？
    - 数据表示是否太臃肿
      - 对象图
      - 对象大小
    - 是否存在内存泄漏

- 新生代调优
  - 新生代的特点
    - 所有的new操作分配内存都是非常廉价的
      - TLAB
    - 死亡对象回收零代价
    - 大部分对象用过即死（朝生夕死）
    - MInor GC 所用时间远小于Full GC
  - 新生代内存越大越好么？
    - 不是
      - 新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降
      - 新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长
    - 新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜

- 幸存区调优
  - 幸存区需要能够保存 **当前活跃对象**+**需要晋升的对象**
  - 晋升阈值配置得当，让长时间存活的对象尽快晋升

# ==类加载==

## 字节码文件结构

- 魔数
  - 可以标识文件格式的常量数值或者文本值。
  - 标识文件的格式使用魔数，而不是扩展名。主要是基于安全方面的考虑，因为文件的扩展名是可以随意修改的。

- 版本
  
  - java版本
  
- 常量池

  - 常量池里面主要存放两个大类：字面量（Literal）和符号引用（Symbolic References）。
    - **字面量**是常量里具体的值（包括 final 修饰的）。
    -  **符号引用**是类的权全限定名、字段的名称和描述符等。

- 访问标志

  - 用于识别一些类或者接口层次的访问信息，接口，访问权限等

- ##### 父类索引

  - 确认类的继承关系

- ##### 字段表集合

  - 类变量，实例变量等

## 语法糖

- 属于编译期的优化
- 所谓的 **语法糖** ，其实就是指 java 编译器把 *.java 源码编译为 \*.class 字节码的过程中，**自动生成**和**转换**的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利

- 默认构造函数
  - 若没有显式提供，则提供一个默认的无参构造函数

- 自动拆装箱
  - 基本类型和其包装类型的相互转换过程，称为拆装箱
  - 编译期完成，运行时性能不会下降

- 泛型集合取值
  - 泛型也是在 JDK 5 开始加入的特性，但 java 在**编译泛型代码后**会执行 **泛型擦除** 的动作，即泛型信息在编译为字节码之后就**丢失**了，实际的类型都当做了 **Object** 类型来处理：

- 可变参数
  - 可变参数 **String…** args 其实是一个 **String[]** args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：

- foreach
  - 遍历数组，不用写i
  - 集合要使用foreach，需要该集合类实现了**Iterable接口**，因为集合的遍历需要用到**迭代器Iterator**

- switch
  - 可以是字符串
  - 可以是枚举

- 枚举类
  - 其实是一个类，编译器帮转化为正常的结构

- 匿名内部类

## 类加载阶段

- 加载
  - 将类的字节码载入方法区
  - 如果这个类还有父类没有加载，**先加载父类**
  - 加载和链接可能是**交替运行**的

- 链接
  - 验证
    - 验证类是否符合 JVM规范，安全性检查
  - 准备
    - 为 static 变量分配空间，设置为默认值
  - 解析
    - 将常量池中的符号引用解析为直接引用

- 初始化
  - 初始化阶段就是**执行类构造器clinit()方法的过程**，虚拟机会保证这个类的构造方法的线程安全
  - clinit()方法是由编译器自动收集类中的所有类变量的**赋值动作和静态语句块**（static{}块）中的语句合并产生的

## 类加载器

- 简介
  - JVM外的程序，通过一个类的全限定名来获取描述该类的二进制字节流，放在外部以便让应用程序自己决定如何去获取所需的类
  - 每个类加载器都有自己的命名空间，同一类加载器下的同一字节码文件的类才相等
- 分类
  - 启动类加载器（BootStrapClassLoader）
    - 用来加载java核心类库，无法被java程序直接引用；
  - 扩展类加载器（Extension ClassLoader）
    - 用来加载java的扩展库，java的虚拟机实现会提供一个扩展库目录，该类加载器在扩展库目录里面查找并加载java类；
  - 系统类加载器（AppClassLoader）
    - 它根据java的类路径来加载类，一般来说，java应用的类都是通过它来加载的；
  - 自定义类加载器
    - 由java语言实现，继承自ClassLoader

## 双亲委派

- 当一个类加载器收到一个类加载的请求
  - 他首先不会尝试自己去加载，而是将这个请求委派给父类加载器去加载
  - 只有父类加载器在自己的搜索范围类查找不到给类时，子加载器才会尝试自己去加载该类；
- 好处
  - 为了防止内存中出现多个相同的字节码
  - 因为如果没有双亲委派的话，用户就可以自己定义一个java.lang.String类，那么就无法保证类的唯一性、安全性。
- 破坏双亲委派模式
  - 自定义类加载器，继承ClassLoader类，重写loadClass方法和findClass方法
  - Tomcat，应用的类加载器优先自行加载应用目录下的 class，并不是先委派给父加载器
  - 热部署

## 运行期优化

- 即时编译器（JIT）与解释器的区别
  - 解释器
    - 将字节码**解释**为机器码，下次即使遇到相同的字节码，仍会执行重复的解释
    - 是将字节码解释为针对所有平台都通用的机器码
  - 即时编译器（缓存）
    - 将一些字节码**编译**为机器码，**并存入 Code Cache**，下次遇到相同的代码，直接执行，无需再编译
    - 根据平台类型，生成平台特定的机器码

- 逃逸优化
  - 逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术
  - 逃逸：对象的作用方法超出当前线程
  - 没有逃逸时
    - 锁消除
      - 去除没有必要的锁
    - 标量替换
      - 标量：不可再分解的量，如基础类型，对象的引用。聚合量：可进一步分解的量，如对象
      - 若一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能
