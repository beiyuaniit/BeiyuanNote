## 步骤

- 和软件工程思想一样。写代码只是整个环节的一小部分
- 在纸上写写思路，处理特殊 情况才是首要任务
- 就像数学一样，要提前验证正确性

## 排序算法复杂度

|       算法       | 稳定性 |          时间复杂度          | 空间复杂度 |           备注           |
| :--------------: | :----: | :--------------------------: | :--------: | :----------------------: |
|     选择排序     |   ×    |        N<sup>2</sup>         |     1      |                          |
|     冒泡排序     |   √    |        N<sup>2</sup>         |     1      |                          |
|     插入排序     |   √    |      N \~ N<sup>2</sup>      |     1      | 时间复杂度和初始顺序有关 |
|     希尔排序     |   ×    | N 的若干倍乘于递增序列的长度 |     1      |      改进版插入排序      |
|     快速排序     |   ×    |            NlogN             |    logN    |                          |
| 三向切分快速排序 |   ×    |          N \~ NlogN          |    logN    |   适用于有大量重复主键   |
|     归并排序     |   √    |            NlogN             |     N      |                          |
|      堆排序      |   ×    |            NlogN             |     1      |    无法利用局部性原理    |

​	快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 	\~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。

​	使用三向切分快速排序，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。

## 数据结构本身的特性

- Stack的先进后出。
- 辅助栈
- HashMap的一一映射关系
- HashSet。无需不重复
- 用ArrayList来模拟只有头节点的链表
- 优先考虑boolean数组而不是HashSet

## 双指针
- 从后面开始想

- 数据、链表：一边遍历，一边完成一些事

## 动态规划

- 在于怎么跳回去

## 利用已知条件

- 最大值为n-1
- 数据全部有序或部分有序

## 二分法

- 注意边界条件

## 关于代码量

- 行数多点没关系
- 关键是逻辑清晰。时间、空间复杂度低点就行

## 中间值

- 用变量保存中间结果。
  - 第i天前的最小值

## 原则

- 不轻易改变原引用指向的值，除非特别说明。
- 有时候改变了反而让程序更加复杂，老老实实声明新的变量
## 原地算法
- 输出是对输入的改变
- 启发
   -  用输入来存储一些中间变量

## 只有小写或大写字母

- 可用int[26]存char和int的映射关系。比用HashMap存储快很多

## 树的顺序存储结构

- 总的来说，要想完整表示一颗二叉树，要有前序、中序或者中序、后序遍历的两个数组
- 或者类似于并查集一样存储其父节点？
- 在这样的数据结构上的dfs的return条件经常是left<right

## 注意

- 有时候太过复杂的方法、有太多限制的方法可以直接抛弃了。
- 多多观察结果的结构
- 超出类型限制反向越界 int long
- 若是2个指针，则可以while(left<=right)    而不用每次想到for()，while更加整洁点
- 逆向思维啥的
- m次询问，则可以事先构造后结果集，询问时直接返回