# ==SSM==

## ==mybatis==

- 官网：https://mybatis.org/mybatis-3/zh/index.html     可支持中文

### 依赖

```xml
<dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.11</version>
      <scope>test</scope>
    </dependency>
    <!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->
    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis</artifactId>
      <version>3.5.6</version>
    </dependency>

    <!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>8.0.22</version>
    </dependency>

  </dependencies>
```

### 包含类路径下.xml

```xml
  <build>
    <resources>
<!--   指定java目录下的配置也拷贝   -->
      <resource>
        <directory>src/main/java</directory>
        <includes>
          <include>**/*.xml</include>
          <include>**/*.properties</include>
        </includes>
      </resource>
    </resources>
  </build>
```

### mysql.properties

```properties
driver=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/beimysql?useUnicode=true&characterEncoding=UTF-8&useSSL=false&serverTimezone=Asia/Shanghai
username=root
password=beiyuan3721
&allowMultiQueries       
```

### SqlMapConfig.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"

        "http://mybatis.org/dtd/mybatis-3-config.dtd">

<configuration>

    <properties resource="mysql.properties"></properties>

    <environments default="development">

        <environment id="development">
            <!--
            配置事务管理器
            type选项
                JDBC:程序员来控制事务
                MANAGED:由容器(如Spring)管理事务
            -->
            <transactionManager type="JDBC"/>
            <!--
            配置数据源
            type选项
                JNDI:java命名和目录接口，在服务端进行数据库连接池的管理
                POOLED:使用数据库连接池
                UNPOOLED:不使用
            -->
            <dataSource type="POOLED">
                <property name="driver" value="${driver}"/>
                <property name="url" value="${url}"/>
                <property name="username" value="${username}"/>
                <property name="password" value="${password}"/>
            </dataSource>
        </environment>
        <!--   上线-->
        <environment id="online">
            <transactionManager type=""></transactionManager>
            <dataSource type=""></dataSource>
        </environment>
    </environments>

    <!--  注册mapper.xml指定方式：resource,url,class.  -->
    <mappers>
        <mapper resource="StudentMapper.xml"/>
    </mappers>
    <!--class是动态代理下的-->
    <mappers>
        <!--<mapper class="mybatisProxy.StusMapper" />-->
        <package name="mybatisProxy"/>
    </mappers> 
 
    
    <!--   输出日志到控制台   -->
    <settings>
        <setting name="logImpl" value="STDOUT_LOGGING"/>
    </settings>
    
    <!--注册别名，这样在StudentMapper.xml就可以用Student代替org.example.Student-->
    <typeAliases >
	<!--  <typeAlias type="org.example.Student" alias="Student"></typeAlias>-->
    <!--  批量注册,一般是没有名字冲突的采用吧。就是导入包  直接使用类名Student或student都行-->
        <package name="org.example"/>
    </typeAliases>
</configuration>
```

### StudentMapper.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- namespace:接口全限定名 。方法签名一致-->
<mapper namespace="mybatisProxy.StusMapper">
    <!--
    如查询全部学生信息
    函数形式:List<Student> getAll(){}
    selecct
        id:不同sql语句的标识
        resultType:结果集类型，如果是集合，则用泛型。底层通过反射创建JavaBean，所以要提供全限名称。一行数据一个对象
			如果是基本数据类型，可以不写
    -->
   <select id="getAll" resultType="org.example.Student" >
       select id,name,email,age from st
   </select>

    <!--
    传入参数
    Student getById(Integer id)
    可以写int，是Integer别名，映射为Java的Integer。
    #{id}中id名字可以乱写？
    -->
    <select id="getById" parameterType="int" resultType="org.example.Student">
        select id,name,email,age from st
        where id=#{id}
    </select>

    <!--
     模糊查询
     List<Student> getByName(String name)
     传递的字符串本身没有单双引号，like后面加上就好了
     #{}是占位符? PreparaedStatement，${}是字符串拼接 Statement
     此处只能是字符串拼接
     -->
    <select id="getByName" parameterType="String" resultType="org.example.Student">
        select id,name,email,age from st
        <!-- where name like '%${name}%'   <!--有sql注入风险-->  
        where name like concat('%',#{name},'%')    <!--解释为占位符where name like concat('%',?,'%')-->
    </select>

    <!--
    增删改查不用手写返回值
    int insert(Student stu)
    values 对应的是Student中的属性
    -->
    <insert id="insertOne" parameterType="org.example.Student">
        insert into st(name,email,age) values(#{name},#{email},#{age})
    </insert>
    
    <!--加了<selectKey>后，会把自增id写进入参数Student stu对象并返回-->
    <insert id="insert" parameterType="Student">
        <selectKey keyProperty="id" resultType="int" order="AFTER"><!--#主键属性、主键类型、执行插入前还是后-->
            select last_insert_id()
        </selectKey>
        insert into st (name,email,age) values (#{name},#{email},#{age})
	</insert>
    
</mapper>
```

### StusMapper.java

- 接口
  - mapper.xml不能直接创建对象，但又想使用其功能，可以通过创建接口mapper.java的代理对象获取
  - 所以直接上这种方法，用xml的自己去看

```java
public interface StudentMapper{
    List<Student> getAll();
    Student getById(Integer id);
    List<Student> getByName(String name);
    int insert(Student stu);
}
```

### MybatisTest.java

```java
public class MybatisTest {

    SqlSession session;
    StudentMapper mapper;
    @Before//每个测试方法执行前都会执行
    public void before() throws IOException {
        //使用输入流读取属性配置文件SqlMapConfig.xml
        InputStream in= Resources.getResourceAsStream("SqlMapConfig.xml");
        //创建SqlSessionFactory工厂
        SqlSessionFactory factory=new SqlSessionFactoryBuilder().build(in);
        //获取SqlSession对象
         session=factory.openSession();
        //获取该接口对象由mybatis动态代理创建的对象
        mapper=session.getMapper(StudentMapper.class);
    }

    @After//同理
    public void after(){
        //关闭SqlSession
        session.close();
    }
    @Test
    public void testStu() throws IOException {
        //执行sql
        //List<Student> list=session.selectList("stu.getAll");//这是不用接口的
        /List<Student> list=mapper.getAll();
        for(Student stu:list){
            System.out.println(stu);
        }
	    List<Student> list1=mapper.getByName("ang");
        for(Student stu:list1){
            System.out.println(stu);
        }
    }

    /*
    增删改查要手动提交事务
     */
    @Test
    public void testCRUD() throws IOException {
        //int res1=session.insert("stu.insertOne",new Student("libai","jingyesi",21));
        int res1=mapper.insertOne(new Student("libai","jingyesi",21));
        session.commit();//这里还是得手动提交
    }
```

### 方法多个参数

- 注解
  - 方法中多个参数时，不写parameterType。是数组也不写

```java
    //查找某属性=某值的列。@Param指定在数据库的列名
    List<Student> getByName(
            @Param("conlumnName") String conlumnName,
            @Param("conlumnValue") String conlumnValue
    );
    <select id="getByName" resultType="Student">
        select id,name,email,age from  st
        where ${conlumnName} like concat('%',#{conlumnValue},'%')
    </select>
   //名字要对应，此处只能$，字符串替换。换成#就查不到结果
```

- 位置参数

  - 有注解情况下

  ```sql
  Available parameters are [conlumnName, conlumnValue, param1, param2]
  ```

  - 无注解情况下

  ```sql
  Available parameters are [arg1, arg0, param1, param2]
  ```

  - where那里直接拿出来用就行了

  ```sql
      <select id="getByName" resultType="Student">
          select id,name,email,age from  st
          where ${arg1} like concat('%',#{arg0},'%')
      </select>
  ```

- Map

  - 和注解相比，不用手动定义，更简洁；和位置参数相比，参数名有明确语义

```java
//顺便处理下日期类。目前就只建库吧
create table stt (
    id int primary key auto_increment,
    name varchar(255),
    age date
);
insert into stt values
(1,'bei','2001-03-02'),
(2,'li','1994-03-02')

List<Student> getByMap(Map map);
//通过key来获取属性
<select id="getByMap" resultType="Student">
    select <include refid="allColumns"></include>#此处是下面的动态SQL定义的代码片段
    from stt
    where age between #{birthgin} and #{birthEnd}
</elect>

@Test
public void testGetByMap(){
    SimpleDateFormat sf=new SimpleDateFormat("yyyy-MM-dd");
    Date begin=sf.parse("1992-02-03");
    Date end=sf.parse("2010-01-02");
    Map map=new HashMap<>();
    map.put("birthBegin",begin);
    map.put("birthEnd",end);
    List<Student>list=mapper.getByMap(map);
}
```

### 动态SQL

- 有些逻辑写在业务逻辑层会比较复杂，在数据访问层写比较灵活
  - 提供定义代码片段，逻辑判断等功能
  - 通过相应标签完成功能
- 代码片段
  - 提高复用性


```xml
<!--  代码片段 sql和include -->
    <sql id="allColumns">
        id,name,email,age
    </sql>

    <select id="selAll" resultType="Student">
        select <include refid="allColumns"></include>
        from st
    </select>
```

- 条件

```xml
<!--  多条件判断  -->
    <select id="selCons" resultType="Student" parameterType="Student">
        select <include refid="allColumns"></include>
        from st
        <where>
            <!-- 模糊查询-->
            <if test="name !=null and name !=''">
                and name like concat('%',#{name},'%')
            </if>
            <!-- 等值查询-->
            <if test="age !=0">
                and age=#{age}
            </if>
        </where>
    </select>
	<!-- 有if成立则加上，没有则减去-->
	<!--select id,name,email,age from st WHERE name like concat('%',?,'%')-->
	<!--select id,name,email,age from st WHERE name like concat('%',?,'%') and age=?-->


<!--  条件更新  -->
    <!--旧的存在问题，如果某个值没有赋值，如name，则会被更新为null。2,null,null,21
-->
    <update id="updateNor" parameterType="Student">
        update st set name =#{name},email=#{email},age=#{age}
        where id=#{id}
    </update>

    <update id="updateCons" parameterType="Student">
        update st
        <set>
            <!--所以先判读有没有值-->
            <if test="name!=null and name!=''">
                name=#{name},
            </if>
            <if test="email!=null and email!=''">
                email=#{email},
            </if>
            <if test="age!=0">
                age=#{age}
            </if>
        </set>
        where id=#{id}
    </update>
	<!--新旧至少要更新一列，否则报错-->
	<!--正常update st SET name=?, email=?, age=? where id=?-->
    <!--一列都不更新，如只给了id。update st where id=?      set字都没有了-->
```

- 遍历批量处理

  - 是传入的参数有多个

  ```xml
  	List<Student> getByIds(Integer []arr);
  	<!--  查询多个指定id的学生信息  -->
  	<select id="getByIds" resultType="Student">
  	    select <include refid="allColumns"></include>
  	    from st
  	    where id in
  	        <foreach collection="array" item="id" separator="," open="(" close=")">
  	            #{id}
  	        </foreach>
  	</select>
  //<foreach>参数
  collection:传入的集合类型。List则写list，Map则map，数组则array
      例如是list，map，则用.来访问字段，如item='stu' stu.age
  item：名字随意，遍历的元素
  separator：每次遍历的分隔符
  open：遍历前增加的字符
  close：遍历后增加的字符
  这些参数来实现sql语句的拼接
  ```

  - 批量增加、删除、查不用设置什么

    - 因为这三个都是在一条语句内，即使改变了多条数据

  - 而批量更新要设置一个参数

    - 一个update的sql语句只能更新一条，所以这里的<foreach>的分隔符是";"来形成多条语句。也就是说是多条语句更新 了多条记录。要设置参数允许多行操作
    - mysql.properties
      - 有些参数有秒用如：&characterEncoding=utf-8

    ```properties
    driver=com.mysql.cj.jdbc.Driver
    url=jdbc:mysql://127.0.0.1:3306/beimysql
    username=root
    password=beiyuan3721
    &allowMultiQueries
    ```

    - StudentMapper.xml

  ```xml
  <update id="updateSet">
  	<foresch collection="list" item="stu" separator=";">//注意这里是分号，一个分号代表一个sql语句的结束
          update st
          <set>
          	...
          </set>
          where id=#{stu.id}
      </foresch>
  </update>
  ```

### 返回值是Map

- 应用，如：多张表，每张都返回一点数据，这时就无法用实体类封装了
- 一行

```xml
//单行
Map getMap(Integer id);
//多行
List<Map> getMaps();

<!--  单行用Map  -->
    <select id="getMap" resultType="map" parameterType="int">
        select name,age
        from st
        where id=#{id}
    </select>
/*
已经放map.put好了，直接拿出来用
Map map=mapper.getMap(2);
System.out.println(map);
结果
没有空值则：{name=tang, age=21}
当name=null：{age=21}
*/

<!--  多行用List<Map>  -->
    <select id="getMaps" resultType="map">
        select name,age
        from st
    </select>
//结果
   	{name=tang, age=21}
	{age=21}
	{name=libai, age=21}
	{name=Kazuha, age=21}
	{name=Tartaglia, age=18}
```

### 字段和列名不一致

- 更准确来说是set方法名和列名不一致
- 列名是否匹配
  - insert into st values(#{name},#{email},#{age})      //No，不是全列名要指定
  - insert into st (name,email,age) values(#{name},#{email},#{age})       //Ok，提供了全列名。即使没有setId
  - insert into st values(2,#{name},#{email},#{age})     //Ok，即使没有提供setId(当时实体类连id字段都忘了设置)


```xml
<!--
	List<Book> getAll();
	实体类
		private Integer id;
		private String name;
		本质上是调用set方法赋值，所以得是setId(),setName().
		若是setBookid(),setBookname()则还是能拿到数据
	数据库
		bookid
		bookname
	不匹配导致拿到的实体对象的属性为null
-->
<!--1.取别名-->
<select id="getAll" resultType="Book">
	select bookid id,bookname,name
    from book
</select>

<!--2.使用resultMap做字段和列名得映射-->
<!-- 映射  -->
	<!--property是实体类中字段名，column是数据库列名或取的别名-->
    <resultMap id="bookMap" type="book">#type是实体类
        <!--主键用id标签-->
        <id property="id" column="bookid"></id>
        <!--其他字段用result标签-->
        <result property="name" column="bookname"></result>
    </resultMap>
<!--  使用  -->
    <select id="getAll" resultMap="bookMap">
        select bookid,bookname
        from book
    </select>
```

### 一二级缓存

- 将用户经常查询的数据放入缓存(内存,再次查询则不用从磁盘的关系数据文件中读取,用于提高查询效率(只是查询),提高了性能
- 缓存流程
  - 从缓存中找,找得到则拿.否则从数据库中查询,放入缓存,返回给用户
  - 缓存中的数据不属于数据库,是java的对象
  - 如果数据表发生了改变,发生了commit操作(一般增删改),则清空缓存,因为更新缓存代价较大.
- 各级缓存
  - 一级缓存
    - 使用SqlSession作用域,同一个sqlSession公用一个
    - mybatis默认开启
  - 二级缓存
    - 使用mapper作用域,可被多个sqlSession共享

- 验证一级缓存

```java
    @Test
    public void testGetOt(){
        Student stu=mapper.getOt(1);
        System.out.println(stu);

        System.out.println("==================");
        Student stu1=mapper.getOt(1);
        System.out.println(stu1);
        System.out.println(stu.equal(stu1));
    }

//第一次打印了数据库操作的相关信息,第二次没有.而且得到的是同一对象
Opening JDBC Connection
Created connection 1306246648.
Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@4ddbbdf8]
==>  Preparing: select id,name,age,email from st where id=?
==> Parameters: 1(Integer)
<==    Columns: id, name, age, email
<==        Row: 1, tang, 21, chuanmanqingmengyaxinghe
<==      Total: 1
Student{id=1, name='tang', email='chuanmanqingmengyaxinghe', age=21}
==================
Student{id=1, name='tang', email='chuanmanqingmengyaxinghe', age=21}
true
```

- 开启二级缓存步骤

  ````xml
  //SqlMapConfig.xml中增加
  <settings>
  	<setting name="cacheEnabled" value="true"></setting>
  </settings>
  
  //具体的mapper.xml中增加
  <mapper namespace="mybatisProxy.StusMapper">
      	<cache></cache>
  </mapper>
  
  //实体类实现serializable接口,可序列化
  ````

## ==spring==

- 官网：https://spring.io/

### 依赖

```xml
<!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.3.0</version>
</dependency>
```

### xml文件注入

- new ->XML Configuration File ->Spring Config              resources/applicationContext.xml

- set方法注入

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

<!--Set方法注入。需要提供无参构造和对应set方法-->
    <!-- 单独一个bean标签就会创建好一个对象  -->
    <bean id="stu" class="org.example.Student" >
        <!--  简单类型和string用value。引用类型用ref，指向一个bean标签的id  -->
        <property name="name" value="libai"></property>
        <property name="age" value="21"></property>
        <property name="school" ref="sch"></property>
    </bean>
    <!--  bean标签没有先后顺序，前面的可以引用后面的  -->
    <bean id="sch" class="org.example.School">
        <property name="name" value="Kassel"></property>
        <property name="address" value="New York"></property>
    </bean>
</beans>


//引用类型注入还可以设置通过类型或名字自动注入,会在整个xml能拿到的对象中匹配.和下面的注解的用名字和类型一致
 <bean id="stu" class="org.example.Student"  autowire="byType">//或者byName
        <!--  简单类型和string用value。引用类型用ref，指向一个bean标签的id  -->
        <property name="name" value="libai"></property>
        <property name="age" value="21"></property>
        <!--<property name="school" ref="sch"></property> 这个可以不要了-->
 </bean>
```

- 构造方法注入

  - 参数名注入

    - 是有构造方法的参数，不是字段名

    ```xml
    <!--  参数名注入 public School(String name, String address)   -->
        <bean id="sch1" class="org.example.School">
            <constructor-arg name="name" value="逐鹿"></constructor-arg>
            <constructor-arg name="address" value="月亮之上"></constructor-arg>
        </bean>
    ```

  - 参数下标注入

    - 从左到右，0、1、2

    ```xml
    <!--  下标对应着参数，所以顺序可交换  -->
        <bean id="sch2" class="org.example.School">
            <constructor-arg index="1" value="上界三千州"></constructor-arg>
            <constructor-arg index="0" value="天仙" ></constructor-arg>
        </bean>
    ```

  - 默认顺序注入

    - 从左到右，已经定了

    ```xml
    <!-- 默认顺序注入   -->
        <bean id="sch4" class="org.example.School">
            <constructor-arg value="天神"></constructor-arg>
            <constructor-arg value="上界"></constructor-arg>
        </bean>
    ```

  - 混合注入

    - 上面三种混搭，只要注入正确即可（不太推荐

    ```xml
    <!--  下标对应着参数，所以顺序可交换  -->
        <bean id="sch2" class="org.example.School">
            <constructor-arg index="1" value="上界三千州"></constructor-arg>
            <constructor-arg name="name" value="天仙" ></constructor-arg>
        </bean>
    ```

### 注解注入

- 常用注解

  - 创建对象
    - @Component
      - 可创建任意对象
    - @Controller
      - 专门创建控制器对象（Servlet），接收
    - @Service
      - 专门创建业务逻辑层对象
    - @Repository
      - 专门创建数据访问层对象
  - 依赖注入
    - @Value
      - 给简单类型注入（8种基本类型+String）
      - 也能获取配置文件yaml，properties的值
    - @Autowired
      - 在最终的xml文件（此处是two.xml)能拿到的对象找一个同源类型的注入
      - 同源类型。
        - 相同类型，父类引用执行子类，接口执向实现类
      - 父子类型都存在时，意味着有多个可以注入的对象。此时再按照对象名和字段名匹配。若有2个相同或者都不匹配，则报错
      - 有实现类对象的话，接口类型引用可以用@Autowired，尽管Idea报红线
    - @Autowried+@Qualifier
      - 根据名称注入，在最终得xml文件（此处是two.xml)能拿到的对象找一个同名同源类型的注入

- 步骤

  - 甚至可以不用set，提供无参构造就行

  ```java
  @Component("school")//可以自己为对象取名
  public class School {
      //用注解注入时可以不用set方法，
      @Value("至尊殿堂")
      private String name;
      @Value("下界")
      private String address;
  }
  
  @Component//创建的对象默认驼峰命名：student
  public class Student {
      @Value("hezhizhang")
      private String name;
      @Value("21")//类型要匹配
      private int age;
      
      @Value("${tencent.cos.file.secretkey}")      //获取properties或yaml中tencent.cos.file.secretkey的值
      private String secretKey;
  
      
      //@Autowired //按类型注入，在最终得xml文件（此处是two.xml)能拿到的对象找一个同源类型的注入
      @Autowired//不加@Autowired，只用@Qualifier的话注入不成功，为null
      @Qualifier("school")//按对象名注入
      private School school;
  }
  ```

- 包扫描

```xml
    <!--  
    会扫描包下的所有类，找有相应注解的类
    建议给的包名精确点，减少消耗，也不易混淆  
      -->
    <!--  多个 可用空格或逗号隔开 -->
    <context:component-scan base-package="org.two org.annomvc,org.example"></context:component-scan>
    <!--  单个包  -->
    <context:component-scan base-package="org.annomvc.dao"></context:component-scan>
```

- 特点
  - 在mvc开发中，有些对象常常只用创建一个。所以注解注入也够用
  - 底层不是用set方法注入：不提供set方法也能完成注入
  - 要有无参构造方法来创建的对象，否则报错

### 获取bean

```java
    public void  stu(){
        //创建容器对象
        ApplicationContext ac=new ClassPathXmlApplicationContext("applicationConfig.xml");
        //取出的都是Object对象
        Student stu=(Student)ac.getBean("stu");
        System.out.println(stu);
    }
```

### SpringAOP

- 常用通知

  - Before:目标方法调用前执行，接口org.springframework.aop.MethodBeforeAdvice
  - After:目标方法调用后执行，接口org.springframe.aop.AfterReturningAdvice
  - Throws：目标方法抛出异常时执行，接口org.springframework.aop.ThrowsAdvice
  - Around:环绕通知，接口org.springframework.intercept.MethodInterceptor
    - 拦截目标对象方法的调用，如事务处理。在执行前和后增加？

- 使用

  - java

  ```java
  public interface BookService {
      //买书
      boolean bug(String userName,String bookName,double price);
      //评论
      void comment(String userName,String comments);
  }
  
  public class BookServiceImpl implements BookService{
      @Override
      public boolean bug(String userName, String bookName, double price) {
          System.out.println(userName+" buys "+" the " +bookName+" cost "+price);
          return true;
      }
  
      @Override
      public void comment(String userName, String comments) {
          System.out.println(userName+"  has made a  comment \""+comments+"\"");
      }
  }
  
  //实现spring提供的通知接口
  public class LogAdvice implements MethodBeforeAdvice {
      /**
       * 可以通过这三个参数获取一些信息
       * @param method   被切入的目标方法
       * @param objects   该目标方法的参数
       * @param o     该目标方法的对象
       * @throws Throwable
       */
      @Override
      public void before(Method method, Object[] objects, Object o) throws Throwable {
          SimpleDateFormat sf=new SimpleDateFormat("yyyy-MM-dd");
          //输出当前时间，被且入的方法，及其实参值
          System.out.println("\n[系统日志]"+sf.format(new Date())+"----"+method.getName()+
                  "----"+ Arrays.toString(objects));
      }
  }
  ```

  - xml

  ```xml
  <!--同过xml完成动态代理的配置-->
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
  <!--  创建 对象 springaop是自己的包 -->
      <bean id="bookServiceTarget" class="springaop.BookServiceImpl"></bean>
      <bean id="logAdvice" class="springaop.LogAdvice"></bean>
  
  <!--  绑定业务和切面  -->
      <bean id="bookService" class="org.springframework.aop.framework.ProxyFactoryBean">
          <!--  配置业务接口 -->
          <property name="interfaces" value="springaop.BookService"></property>
          <!-- 配置切面-->
          <property name="interceptorNames">
              <!--列表说明切面可以有多个-->
              <list>
                  <value>logAdvice</value>
              </list>
          </property>
          <!--放入-->
          <property name="target" ref="bookServiceTarget"></property>
      </bean>
  </beans>
  ```

  

### AspectJAOP

- 概述

  - 很多框架都实现了AOP功能，Spring是其一，AspectJ也是。且其实现方式更为简洁，还支持注解式开发，易学易用

  - 官网：http://www.eclipse.org/aspectj/

- 常用注解

  - 前置通知@Before
  - 后置通知@AfterReturning
  - 环绕通知@Around
  - 最终通知@After
  - 定义切入点@Pointcut       可简写切入点表达式

- 切入点表达式

  - 用来指定切入点

  ```java
  execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?
           name-pattern(param-pattern) throws-pattern?)
  
  modifiers-pattern 访问权限
  ret-type-pattern  返回值类型（必选
  declaring-type-pattern    类的全限定名
  name-pattern(param-pattern)    方法名(参数类型)（必选
  throws-pattern        抛出的异常类型
  ?			后面有问号的表示可选
      
  通配符
  *		任意多个字符
  ..		在方法参数中表示任意参数
  .*		该包下的所有类
  ..*		表示本路径及其所有子路径
  .*		前有一个包
  ..*		前有任意多个包
  
  类名支持通配符，类名和方法名间常用.连接
  实例
  execution(public * *())			任意公共方法
  execution(* set*(..))			任意以set开头的方法
  execution(* demo.service.*.*(..))	demo.service包下的任意方法（不包含子包
  execution(* demo.service..*.*(..))  demo.service包及其子包下的任意方法
  execution(* *.demo.service.*.*(..))	前只有一个包下的demo.service包下的任意方法
  execution(* *..demo.service.*.*(..))	前有任意个包都行
  ```

- 步骤

  - 添加依赖

  ```xml
     <!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
      <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.3.0</version>
      </dependency>
  	<!--用和spring-context版本一致的吧-->
      <!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects -->
      <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-aspects</artifactId>
        <version>5.3.0</version>
      </dependency>
  ```

  

  - 前置通知

    - 只能拿到方法签名（方法头），不能拿到返回值

    ```java
    //业务接口和实现类
    public interface SomeService {
        String doSome(String name,int age);
    }
    //@Service  注解注入
    public class SomeServiceImpl implements SomeService{
        @Override
        public String doSome(String name, int age) {
            System.out.println(name+" 执行了doSome方法 "+age);
            return "abc";
        }
    }
    
    //切面类。用来声明切面方法
    @Aspect         //交给AspectJ框架去识别切面类
    //@Component  注解注入
    public class MyAspect {
        /*
        切面的功能都是由切面方法来完成
        前置通知规范
            访问权限是public
            返回值是void
            方法名自定义
            没有参数，有也只能是JoinPoint类型
            用@Before注解声明前置切入及其切入点
                属性:value 指定切入点表达式
         */
        @Before(value="execution(public String aspectj.SomeService.doSome(String,int))")//较完整的
        public void myBefore(){
            System.out.println("doSome 方法的前置通知");
        }
    }
    
    //spring配置文件（用注解形式来创建对象和依赖注入也行）
    <!--  创建对象  -->
    <bean id="someService" class="aspectj.SomeServiceImpl"></bean>
    <bean id="myAspect" class="aspectj.MyAspect"></bean>
    <!--
        注解方式不用bean标签创建对象，但是要添加包扫描
         <context:component-scan base-package="aspectj"></context:component-scan>
    -->
    <!--  由AspectJ根据注解自动绑定切面和业务  -->
    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>
     
    //测试
    ApplicationContext ac=new ClassPathXmlApplicationContext("aspectj/applicationContext.xml");
    SomeService someService=(SomeService)ac.getBean("someService");//注解注入的话是取驼峰someServiceImpl
    someService.doSome("baijvyi",21);
    
    
    //若是想要拿到方法相关信息，则用JoinPoint对象
    @Before(value="execution(* aspectj.SomeService.*(..))")
    public void myBefore1(JoinPoint jp){
        System.out.println("方法签名："+jp.getSignature());
        System.out.println("实参 "+ Arrays.toString(jp.getArgs()));
    }
    
    ```

  - 后置通知

  ```java
      /*
      后置通知规范
          权限public
          返回值void
          名称自定义
          可有参数(常用 Object obj为目标方法执行后的返回值,void则为null)，目前好像只能有这一个参数
              当然也可以没有，无论目标方法本身有没有参数
          @AfterReturning注解
              value:切入点表达式
              returning:指定目标方法返回值名称，得与切面方法的参数一致。没有参数可以不写这个属性
  
       */
      @AfterReturning(value = "execution(* aspectj.SomeServiceImpl.doAfterReturn(..))",returning="obj")
      public void myAfterReturning(Object obj){
          System.out.println("后置通知");
          if(obj!=null){
              //分情况来决定是否可以改变目标方法的返回值
              if(obj instanceof String){
                  //8种基本类型和String都不可以改变
                  obj=obj.toString().toLowerCase();//无影响
              }
              if(obj instanceof SomeService){
                  //引用类型，可以改变
              }
          }
      }
  ```

  - 环绕通知

    - 通过拦截目标方法，在其前后增强功能，功能最强大,环绕方法的返回值就作为目标方法的返回值。（事务一般就用这个）

    ```java
     /*
        环绕通知规范
            权限是public
            返回值作为目标方法的返回值
            方法名自定义
            有参数，此参数就是目标方法
            回避（抛出）Throwable异常。why？
            @Around
                value:切入点表达式
         */
        @Around(value = "execution(* aspectj.SomeServiceImpl.doAround(String))")
        public String aroundAspect(ProceedingJoinPoint pjp) throws Throwable {
            System.out.println("前Around");
    
            //传递参数，调用目标方法，初步拿到目标方法返回值
            Object obj=pjp.proceed(pjp.getArgs());//此处要抛出Throwable。
    
            System.out.println("后Around");
            return obj.toString().toUpperCase();//这里才作为目标方法最终的返回值
        }
    ```

  - 最终通知

    - 无论目标方法是否正常执行，最终通知的代码都会被执行。类似于try-catch-finally种的finally语句块

    ```java
        /*
        最终通知规范
            权限public
            返回值void
            方法名自定义
            方法可没有参数，有也只能是JoinPoint类型
            @After
                value:切入点表达式
         */
        @After(value = "execution(* aspectj.SomeServiceImpl.doAfter(..))")
        public void myAfter(JoinPoint jp){
            System.out.println("签名 "+jp.getSignature());
            System.out.println("After");
        }
    ```

    

- 给切面表达式取别名

  - @Pointcut

  ```java
      //切入点表达式取别名
      @Pointcut(value = "execution(* aspectj.SomeServiceImpl.doAll(..))")
      public void myCut(){}
  
      //取的时候直接调用函数
      @Before(value = "myCut()")
      public void myBefore1(){
          System.out.println("@Before");
      }
  ```

- 若方法出现异常

  - 后置通知和环绕通知的后置通知不会执行

- 不同通知的执行顺序

  - 多个相同的通知呢？再说吧

  ```java
  @Around-pre					//前环绕
  @Before						//前置
  doAll method execute		//目标方法
  @AfterReturning				//后
  @After						//最终
  @Around-next				//后环绕
  ```

- 代理模式切换

  - 默认是JDK动态代理，只能接口引用来接收对象，因为底层已经是代理对象

  ```java
  <aop:aspectj-autoproxy></aop:aspectj-autoproxy>
  SomeService someService=(SomeService)ac.getBean("SomeService");
  ```

  - 改为CGLib子类动态代理,用接口或实现类接都行

  ```java
  <aop:aspectj-autoproxy proxy-target-class="true"></aop:aspectj-autoproxy>
  SomeService someService=(SomeService)ac.getBean("SomeService");
  SomeServiceImpl someService=(SomeServiceImpl)ac.getBean("SomeService");
  ```

  - 一般用JDK动态代理就够了。都用接口来接没错

### Spring注解式事务

- @Transactional添加到类上，则对类中所有方法生效（不灵活）。添加到方法上，则只对该方法生效（太繁琐）

- spring事务默认自动提交，且出错不回滚

  - 如在service层出错，但是还是增加成功了

  ```java
  @Service
  public class UserServiceImpl implements UserService {
      @Autowired
      UserMapper mapper;
      @Override
      public int insert(User user) {
          int res=mapper.insert(user);
          int error=1/0;
          return res;
      }
  }
  ```

  

- 添加事务管理

  - applicationContext_service.xml

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd">
          <!--sm基于注解开发,添加包扫描-->
          <context:component-scan base-package="sm.service.impl"></context:component-scan>
          <!-- 通常事务处理都是放在service层 -->
          <!--要用到里面配置的数据源等。这里引进了，但时候用ac=new ...(..service.xml)就行了-->
          <import resource="applicationContext_mapper.xml"></import>
          <!--添加事务管理器-->
          <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
                  <!--配置数据源。ref是mapper中配置好的-->
                  <property name="dataSource" ref="dataSource"></property>
          </bean>
          <!--
          添加注解驱动（解析注解@Transactional？)
              annotation-driven http://ww.springframe.org/schema/tx   后缀得是tx
               transaction-manager是上面的事务管理器id
          -->
          <tx:annotation-driven transaction-manager="transactionManager"></tx:annotation-driven>
  </beans>
  ```

  - 在service实现类添加注解@Transactional

    ```java
    @Service
    //propagation用来指定事务隔离级别，增删改都用REQUIRED
    @Transactional(propagation = Propagation.REQUIRED)
    public class UserServiceImpl implements UserService {
        @Autowired
        UserMapper mapper;
        @Override
        public int insert(User user) {
            int res=mapper.insert(user);
            int error=1/0;
            return res;
        }
    }
    //经测试，添加成功了，出错后事务被回滚了
    ```

  - @Transactional的其他属性

  ```java
  @Transactional(propagation = Propagation.REQUIRED,//事务隔离级别（增删改都用REQUIRED
          noRollbackForClassName = "ArithmeticException",//发生该异常不回滚.使用异常名
          noRollbackFor = ArithmeticException.class,//发生该异常不回滚，使用异常类型
          rollbackForClassName = "",//发生了该异常一定回滚
          //rollbackFor = ArithmeticException.class,//发生了该异常一定回滚
          timeout = -1,//事务有效时间，超过自动回滚。默认-1，永不超时
          readOnly = false,//修改数据权限，查询则要设置为true
          isolation = Isolation.DEFAULT//设置数据库隔离级别。此处表示使用默认
  )
  ```

### spring声明式事务

- 在配置文件中按照条件配置。一次可配置一大堆（推荐使用

- 步骤

  - 项目中方法的命名要有规范才好匹配

    - 增加      add     save	insert	
    - 更新       update  change    modify   set
    - 删除       delete    drop       remove     clear
    - 查询       select     find      search       get

  - 三个文件各司其职，最后用total整合

    - mapper

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <beans //spring配置文件头啥的就不写在这里>
    
        <!--读取属性配置文件-->
        <context:property-placeholder location="mysql.properties" ></context:property-placeholder>
    
        <!--  创建数据源  用Druid连接池-->
        <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
            <!--  怎么读取不了配置文件${driver}.明明上面已经加载成功了   -->
            <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"></property>
            <property name="url" value="jdbc:mysql://127.0.0.1:3306/beimysql"></property>
            <property name="username" value="root"></property>
            <property name="password" value="beiyuan3721"></property>
        </bean>
        <!--  配置SqlSessionFactoryBean类  完成mybatis中SqlSessionFactory类的功能-->
        <bean class="org.mybatis.spring.SqlSessionFactoryBean">
            <!--  配置数据源,用上面配置好的  -->
            <property name="dataSource" ref="dataSource"></property>
            <!--  配置mybatis核心配置文件.毕竟有些功能要在这里完成  -->
            <property name="configLocation" value="SqlMapConfig.xml"></property>
            <!--  注册实体类别名,类就可以不用全限定名了   -->
            <property name="typeAliasesPackage" value="sm.pojo"></property>
        </bean>
        <!--
            注册mapper.xml   让该配置文件知道mapper在哪
            由mybatis自己创建相应访问数据库的mapper对象
            不取id,反正程序员自己又用不到,系统调用就行
        -->
        <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
            <property name="basePackage" value="sm.mapper"></property>
        </bean>
    </beans>
    ```

    - service

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <beans>
        <!--sm基于注解开发,添加包扫描。目前就为了创建相应service对象-->
        <context:component-scan base-package="sm.service.impl"></context:component-scan>
        <!-- 通常事务处理都是放在service层 不过为了管理，还是统一放在applicationContext_transaction.xml中-->
    </beans>
    ```

    - transaction

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <beans>
    
        <!--添加事务管理器-->
        <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
            <!--报红没关系，最后用total.xml整合-->
            <property name="dataSource" ref="dataSource"></property>
        </bean>
        
        <!--
        有些事务想要自己的特性
            可通过注解来单独指定
            并注解事务的优先级order设置得比声明的高
        -->
        <tx:annotation-driven order="66"></tx:annotation-driven>
       <!--配置事务切面。advice  http://www.springframework.org/schema/tx  后缀还是tx-->
        <tx:advice id="myadvice" transaction-manager="transactionManager">
            <tx:attributes>
                <!--name去匹配相应方法。其他的则是设置其属性-->
                <tx:method name="*select*" read-only="true"/>
                <tx:method name="*insert*" propagation="REQUIRED"/>
                <tx:method name="*update*" propagation="REQUIRED"/>
                <tx:method name="*delete*" propagation="REQUIRED"/>
                <tx:method name="*" propagation="SUPPORTS"/>
            </tx:attributes>
        </tx:advice>
        <!--绑定切面和切入点-->
        <aop:config>
            <!--切入点-->
            <aop:pointcut id="mypoint" expression="execution(* sm.service.impl.*.*(..))"/>
            <!--绑定-->
            <!--优先级order设置得比注解式低-->
            <aop:advisor advice-ref="myadvice" pointcut-ref="mypoint" order="7"></aop:advisor>
        </aop:config>
    </beans>
    ```

    - total

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <beans>
        <!--整合-->
        <import resource="applicationContext_service.xml"></import>
        <import resource="applicationContext_mapper.xml"></import>
        <import resource="applicationContext_transaction.xml"></import>
    </beans>
    ```

## ==springmvc==

### 依赖

- 创建web工程

```xml
<!--一个依赖可对应多个jar包，会把所依赖的jar包都导入进来-->
<dependencies>
    <!-- SpringMVC -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-webmvc</artifactId>
        <version>5.3.1</version>
    </dependency>

    <!-- 日志 -->
    <dependency>
        <groupId>ch.qos.logback</groupId>
        <artifactId>logback-classic</artifactId>
        <version>1.2.3</version>
    </dependency>

    <!-- ServletAPI -->
    <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>javax.servlet-api</artifactId>
        <version>3.1.0</version>
        <scope>provided</scope>//由服务器提供
    </dependency>

    <!-- Spring5和Thymeleaf整合包 -->
    <dependency>
        <groupId>org.thymeleaf</groupId>
        <artifactId>thymeleaf-spring5</artifactId>
        <version>3.0.12.RELEASE</version>
    </dependency>
</dependencies>
```

### web.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <filter>
        <filter-name>CharacterEncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
        <init-param>
            <param-name>forceResponseEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>CharacterEncodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>


    <!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 -->
    <servlet>
        <servlet-name>springMVC</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 -->
        <init-param>
            <!-- contextConfigLocation为固定值 -->
            <param-name>contextConfigLocation</param-name>
            <!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources -->
            <param-value>classpath:SpringMVC.xml</param-value>
        </init-param>
        <!--
             作为框架的核心组件，在启动过程中有大量的初始化操作要做
            而这些操作放在第一次请求时才执行会严重影响访问速度
            因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时
        -->
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>springMVC</servlet-name>
        <!--
            设置springMVC的核心控制器所能处理的请求的请求路径
            /所匹配的请求可以是/login或.html或.js或.css方式的请求路径
            但是/不能匹配.jsp请求路径的请求
        -->
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

### SpringMVC.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <context:component-scan base-package="demo01.controller"></context:component-scan>

    
    <mvc:annotation-driven/>
    <!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象-->
    <bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"></bean>

    <!-- 配置Thymeleaf视图解析器 -->
    <bean id="viewResolver" class="org.thymeleaf.spring5.view.ThymeleafViewResolver">
        <property name="order" value="1"/>
        <property name="characterEncoding" value="UTF-8"/>
        <property name="templateEngine">
            <bean class="org.thymeleaf.spring5.SpringTemplateEngine">
                <property name="templateResolver">
                    <bean class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver">

                        <!-- 视图前缀 补充：这些界面不能直接访问，只能通过转发来访问-->
                        <property name="prefix" value="/WEB-INF/templates/"/>

                        <!-- 视图后缀 -->
                        <property name="suffix" value=".html"/>
                        <property name="templateMode" value="HTML5"/>
                        <property name="characterEncoding" value="UTF-8" />
                    </bean>
                </property>
            </bean>
        </property>
    </bean>



<!--    <bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">-->
<!--        <property name="exceptionMappings">-->
<!--            <props>-->
<!--                &lt;!&ndash;-->
<!--                    properties的键表示处理器方法执行过程中出现的异常-->
<!--                    properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面-->
<!--                &ndash;&gt;-->
<!--                <prop key="java.lang.ArithmeticException">error</prop>-->
<!--            </props>-->
<!--        </property>-->
<!--        &lt;!&ndash;-->
<!--            exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享-->
<!--        &ndash;&gt;-->
<!--        <property name="exceptionAttribute" value="ex"></property>-->
<!--    </bean>-->
</beans>
```

### @RequestMapping

```java
@RequestMapping(
        value = {"/testRequestMapping", "/test"},
        method = {RequestMethod.GET, RequestMethod.POST,RequestMethod.DELETE},//满足value之一和method之一的能匹配成功
    	params = {"username","password=123456"},//param要带，！params不要带。param!=value
    	headers={"User-Agent=Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.71 Safari/537.36 Core/1.94.169.400 QQBrowser/11.0.5130.400"}
)
public String testRequestMapping(){
    return "success";
}
```

- 同理还有@GetMapping、@PostMapping、@PutMapping、@DeleteMapping

- 支持ant风格的路径

  - ？：表示任意的单个字符

    *：表示任意的0个或多个字符

    \**：表示任意多层目录(0~n  b

    注意：在使用\**时，只能使用/**/xxx的方式。

    ```java
    若是a**b  则解析为2个*，不能匹配多级目录
    
    @GetMapping("/a?c/ant")
    public String testAnt(){
        return "success";
    }
    ```

### 获取请求参数



- 1、@PathVariable

  原始方式：/deleteUser?id=1

  rest方式：/deleteUser/1        请求路径传递参数

  SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参

```html
<a th:href="@{/testRest/1/admin}">测试路径中的占位符-->/testRest</a><br>
```

```java
@RequestMapping("/testRest/{id}/{username}")
public String testRest(@PathVariable("id") String id, @PathVariable("username") String username){
    System.out.println("id:"+id+",username:"+username);
    return "success";
}
//最终输出的内容为-->id:1,username:admin
//参数不全或没有则不匹配，报404：/testRest/1/  /testRest/1       /testRest
```

​     只能用于接收url路径上的参数,一般用于get和delete请求

- 2、@RequestParam

  形参名和实参名不一致，建立映射关系

  @RequestParam是将请求参数和控制器方法的形参创建映射关系

  @RequestParam注解一共有三个属性：

  value：指定为形参赋值的请求参数的参数名

  required：设置是否必须传输此请求参数，默认值为true

  若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter 'xxx' is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null

  defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为""时，作为形参的默认值

  username=&password=123时传了username但值是空串"",如文本框为空

```java
//username是前端的参数名
public String testParam(String id,@RequestParam(value="username",defaultValue="libai") String name){}
```

​     只能用于接收请求体带的参数，一般用于post请求

- 3、通过ServletAPI获取

​    将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象

```java
@RequestMapping("/testParam")
public String testParam(HttpServletRequest request){
    String username = request.getParameter("username");
    String password = request.getParameter("password");
    System.out.println("username:"+username+",password:"+password);
    return "success";
}
```

- 4、通过控制器方法的形参获取请求参数

  形参和实参名一致

  在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参

```html
<a th:href="@{/testParam(username='admin',password=123456)}">测试获取请求参数-->/testParam</a><br>
```

```java
@RequestMapping("/testParam")
public String testParam(String username, String password){
    System.out.println("username:"+username+",password:"+password);
    return "success";
}
```

> 注：
>
> 若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数
>
> 若使用字符串数组类型的形参，此参数的数组中包含了每一个数据
>
> 若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果
>
> ​	如：一复选框名  hobby  值 rain  sun  day     
>
> ​    String hobby--->hobby:rain,sun,day           中间用逗号隔开
>
> ​    String[]hobby--->hobby:[rain,sun,day]

- 5、@RequestHeader

  @RequestHeader是将请求头信息和控制器方法的形参创建映射关系

  @RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam

  如：@RequestHeader("Host") String host

- 6、@CookieValue

  @CookieValue是将cookie数据和控制器方法的形参创建映射关系

  @CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam

- 7、通过POJO获取请求参数

  可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值

```html
<form th:action="@{/testpojo}" method="post">
    用户名：<input type="text" name="username"><br>
    密码：<input type="password" name="password"><br>
    性别：<input type="radio" name="sex" value="男">男<input type="radio" name="sex" value="女">女<br>
    年龄：<input type="text" name="age"><br>
    邮箱：<input type="text" name="email"><br>
    <input type="submit">
</form>
```

```java
@RequestMapping("/testpojo")
public String testPOJO(User user){
    System.out.println(user);
    return "success";
}
//最终结果-->User{id=null, username='张三', password='123', age=23, sex='男', email='123@qq.com'}
```

- 7、解决获取请求参数的乱码问题

  解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册

  tomcat9：post请求提交时会有乱码，get不会。tomcat10好像都解决了

```xml
<!--配置springMVC的编码过滤器-->
<filter>
    <filter-name>CharacterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
    <init-param>
        <!--
		默认值为false，要设置为true才能过滤，因为     
		if (encoding != null) {
            if (this.isForceRequestEncoding() || request.getCharacterEncoding() == null) {
                request.setCharacterEncoding(encoding);
            }

            if (this.isForceResponseEncoding()) {
                response.setCharacterEncoding(encoding);
            }
        }
		-->
        <param-name>forceResponseEncoding</param-name>
        <param-value>true</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>CharacterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

> 注：
>
> SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效

- 8获取表单中参数

```java
public void test(HttpServletRequest request){
    try{
        User user =new ObjectMapper().readValue(request.getInputStream(),User.class)
    }catch{
        
    }
}
```



### 域对象共享数据

- 选择能实现功能、范围最小的域对象存数据

- 使用jsp的pageContext来获取（由于这不使用，所以就不讲了

- 1、使用ServletAPI向request域对象共享数据

  1、2、3、4、5都是request域

```java
@RequestMapping("/testServletAPI")
public String testServletAPI(HttpServletRequest request){
    request.setAttribute("testScope", "hello,servletAPI");
    return "success";
}

//前端通过thymeleaf获取
<p th:text="${testScope}"></p>
```

- 2、使用ModelAndView向request域对象共享数据

```java
@RequestMapping("/testModelAndView")
public ModelAndView testModelAndView(){
    /**
     * ModelAndView有Model和View的功能
     * Model主要用于向请求域共享数据
     * View主要用于设置视图，实现页面跳转
     */
    ModelAndView mav = new ModelAndView();
    //向请求域共享数据
    mav.addObject("testScope", "hello,ModelAndView");
    //设置视图，实现页面跳转
    mav.setViewName("success");
    return mav;
}
```

- 3、使用Model向request域对象共享数据

```java
@RequestMapping("/testModel")
public String testModel(Model model){
    model.addAttribute("testScope", "hello,Model");
    return "success";
}
```

- 4、使用map向request域对象共享数据

```java
@RequestMapping("/testMap")
public String testMap(Map<String, Object> map){
    map.put("testScope", "hello,Map");
    return "success";
}
```

- 5、使用ModelMap向request域对象共享数据

```java
@RequestMapping("/testModelMap")
public String testModelMap(ModelMap modelMap){
    modelMap.addAttribute("testScope", "hello,ModelMap");
    return "success";
}
```

- 6、Model、ModelMap、Map的关系

Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的（接口的实现类

```
public interface Model{}
public class ModelMap extends LinkedHashMap<String, Object> {}
public class ExtendedModelMap extends ModelMap implements Model {}
public class BindingAwareModelMap extends ExtendedModelMap {}
```

- 7、向session域共享数据

springmvc有 一个注解可以在请求域共享数据时也在session域中存 一份，但是不太好用，建议 用原生servlet

```java
@RequestMapping("/testSession")
public String testSession(HttpSession session){
    session.setAttribute("testSessionScope", "hello,session");
    return "success";
}
//前端获取
<p th:text="${session.testSessonScope}"></p>
```

- 8、向application域共享数据

```java
@RequestMapping("/testApplication")
public String testApplication(HttpSession session){
	ServletContext application = session.getServletContext();
    application.setAttribute("testApplicationScope", "hello,application");
    return "success";
}
}
//前端获取
<p th:text="${application.testSessonScope}"></p>
```

### 视图

​	SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户

​	SpringMVC视图的种类很多，默认有转发视图和重定向视图

​	当工程引入jstl的依赖，转发视图会自动转换为JstlView

​	若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是	ThymeleafView

- 1、ThymeleafView

  当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转

  但是要怎么使用这个视图的转发呢？return "param02";直接这样跳转到RequestMapping("param02")是不行的

```java
@RequestMapping("/testHello")
public String testHello(){
    return "hello";
}
```

![](B:/我的坚果云/springmvc/img/img002.png)

- 2、转发视图

​	SpringMVC中默认的转发视图是InternalResourceView

​	SpringMVC中创建转发视图的情况：

​	当控制器方法中所设置的视图名称以"forward:"为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀"forward:"去掉，剩余部分作为最终路径通过转发的方式实现跳转

​	例如"forward:/"，"forward:/employee"

```java
@RequestMapping("/testForward")
public String testForward(){
    //秒啊，此处转发到的是一个下一个RequestMapping("/testHello")匹配的请求处理方法
    //转发到下一个请求处理
    return "forward:/testHello";
    //配置的视图解析器将失效
    //也可以是具体的页面。（若想具体页面，那就不加前缀
    //return "forward:/html/index.html";//转发到webapp/html/index.html;
}
```

![image-20210706201316593](B:/我的坚果云/springmvc/img/img003.png)

配置默认的

```xml
<!--  视图解析器  -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <!--前后缀。在webapp/jsp目录下的wel.jsp写路径时只需要写wel即可-->
        <property name="prefix" value="/jsp/"></property>
        <property name="suffix" value=".jsp"></property>
    </bean>
```

- 3、重定向视图

  SpringMVC中默认的重定向视图是RedirectView

  当控制器方法中所设置的视图名称以"redirect:"为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀"redirect:"去掉，剩余部分作为最终路径通过重定向的方式实现跳转

例如"redirect:/"，"redirect:/employee"

```java
@RequestMapping("/testRedirect")
public String testRedirect(){
    return "redirect:/testHello";
    //使用和转发同理
}
```

![image-20210706201602267](B:/我的坚果云/springmvc/img/img004.png)

> 注：
>
> 重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径

- 4、视图控制器view-controller

  当控制器方法中，仅仅用来实现页面跳转，不需要处理，如只需要请求即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示

```xml
<!--
	path：设置处理的请求地址
	view-name：设置请求地址所对应的视图名称
	可用于通过请求直接从服务器拿页面
-->
<mvc:view-controller path="/" view-name="index"></mvc:view-controller>
```

> 注：
>
> 当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，要想生效，需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：
>
> ```xml
> <mvc:annotation-driven />
> ```

### HttpMessageConverter

​	HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文

​	HttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，

​	ResponseEntity。（操作响应比较常见

- 1、@RequestBody

  @RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值。可以是对象

```html
<form th:action="@{/testRequestBody}" method="post">
    用户名：<input type="text" name="username"><br>
    密码：<input type="password" name="password"><br>
    <input type="submit">
</form>
```

```java
@RequestMapping("/testRequestBody")
public String testRequestBody(@RequestBody String requestBody){
    System.out.println("requestBody:"+requestBody);
    return "success";
}
```

   输出结果：

   requestBody:username=admin&password=123456

- 2、RequestEntity

  RequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息

```java
@RequestMapping("/testRequestEntity")
public String testRequestEntity(RequestEntity<String> requestEntity){
    System.out.println("requestHeader:"+requestEntity.getHeaders());
    System.out.println("requestBody:"+requestEntity.getBody());
    return "success";
}
```

输出结果：
requestHeader:[host:"localhost:8080", connection:"keep-alive", content-length:"27", cache-control:"max-age=0", sec-ch-ua:"" Not A;Brand";v="99", "Chromium";v="90", "Google Chrome";v="90"", sec-ch-ua-mobile:"?0", upgrade-insecure-requests:"1", origin:"http://localhost:8080", user-agent:"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36"]
requestBody:username=admin&password=123

- 3、@ResponseBody

  @ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器

  可用于返回給ajax请求。返回数据到响应体

  返回的是原地址？返回给了请求路径

```java
//原生用HttpResponse response响应数据
//response.getWriter().print("success is not far away");
@RequestMapping("/testResponseBody")
@ResponseBody
public String testResponseBody(){
    return "success";//不再被视图解析器解析
}
```

结果：浏览器页面显示success

- 4、SpringMVC处理json

  @ResponseBody处理json的步骤：（将响应数据转为json

  a>导入jackson的依赖

```xml
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.12.1</version>
</dependency>
```

​		b>在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：	MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串

```
<mvc:annotation-driven />
```

​	c>在处理器方法上使用@ResponseBody注解进行标识

​	d>将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串

```java
@RequestMapping("/testResponseUser")
@ResponseBody
public User testResponseUser(){
    return new User(1001,"admin","123456",23,"男");
}
```

浏览器的页面中展示的结果：

{"id":1001,"username":"admin","password":"123456","age":23,"sex":"男"}

- 5、SpringMVC处理ajax

a>请求超链接：

```html
<div id="app">
	<a th:href="@{/testAjax}" @click="testAjax">testAjax</a><br>
</div>
```

b>通过vue和axios处理点击事件：

```html
<script type="text/javascript" th:src="@{/static/js/vue.js}"></script>
<script type="text/javascript" th:src="@{/static/js/axios.min.js}"></script>
<script type="text/javascript">
    var vue = new Vue({
        el:"#app",
        methods:{
            testAjax:function (event) {
                axios({
                    method:"post",
                    url:event.target.href,
                    params:{
                        username:"admin",
                        password:"123456"
                    }
                }).then(function (response) {
                    alert(response.data);
                });
                event.preventDefault();
            }
        }
    });
</script>
```

c>控制器方法：

```java
@RequestMapping("/testAjax")
@ResponseBody
public String testAjax(String username, String password){
    System.out.println("username:"+username+",password:"+password);
    return "hello,ajax,over";
}
```

- 6、@RestController注解

  @RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解

- 7、ResponseEntity

  ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文

### 文件上传和下载

- 1、文件下载

使用ResponseEntity实现下载文件的功能（把文件作为响应体

```java
@RequestMapping("/testDown")
public ResponseEntity<byte[]> testResponseEntity(HttpSession session) throws IOException {
    //获取ServletContext对象
    ServletContext servletContext = session.getServletContext();
    //获取服务器中文件的真实路径
    String realPath = servletContext.getRealPath("/static/img/1.jpg");//
    //创建输入流
    InputStream is = new FileInputStream(realPath);
    //创建字节数组
    byte[] bytes = new byte[is.available()];//is.available()文件的字节数
    //将流读到字节数组中
    is.read(bytes);
    //创建HttpHeaders对象设置响应头信息
    MultiValueMap<String, String> headers = new HttpHeaders();
    //设置要下载方式以及下载文件的名字
    headers.add("Content-Disposition", "attachment;filename=1.jpg");
    //设置响应状态码
    HttpStatus statusCode = HttpStatus.OK;
    //创建ResponseEntity对象
    ResponseEntity<byte[]> responseEntity = new ResponseEntity<>(bytes, headers, statusCode);
    //关闭输入流
    is.close();
    return responseEntity;
}
```

- 2、文件上传

文件上传要求form表单的请求方式必须为post，并且添加属性enctype="multipart/form-data"把数据以二进制传输到服务器

SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息

上传步骤：

a>添加依赖：

```xml
<!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload -->
<dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.3.1</version>
</dependency>
```

b>在SpringMVC的配置文件中添加配置：

```xml
<!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象,id要写，且名字只能是下面这个-->
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"></bean>
```

c>控制器方法：

```java
@RequestMapping("/testUp")
public String testUp(MultipartFile photo, HttpSession session) throws IOException {
    //获取上传的文件的文件名
    String fileName = photo.getOriginalFilename();
    //处理文件重名问题
    String hzName = fileName.substring(fileName.lastIndexOf("."));//后缀名还是得要.png
    fileName = UUID.randomUUID().toString().replaceAll("-","") + hzName;
    //获取服务器中photo目录的路径
    ServletContext servletContext = session.getServletContext();
    String photoPath = servletContext.getRealPath("photo");
    File file = new File(photoPath);
    if(!file.exists()){
        file.mkdir();
    }
    String finalPath = photoPath + File.separator + fileName;
    //实现上传功能。意为将浏览器的文件转移到服务器，先读再写
    photo.transferTo(new File(finalPath));
    return "success";
}
```

   d>前端页面

```html
<form th:action="@{/testUp}" method="post" enctype="multipart/form-data">
    头像：<input type="file" name="photo"><br>
    <input type="submit" value="上传">
</form>
```

结果

​	放在了服务器的目录下了C:\Program Files\Java\apache-tomcat-9.0.60\webapps\SpringMVC\photo

### 拦截器

- 1、拦截器的配置

  SpringMVC中的拦截器用于拦截控制器方法的执行

  在控制器方法执行前后进行一些操作，Interceptor（拦截器

  SpringMVC中的拦截器需要实现HandlerInterceptor

  SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：

```xml
<!--  包扫描  -->
    <context:component-scan base-package="demo01.interceptor"></context:component-scan>
<!-- 配置拦截器   -->
    <mvc:interceptors>
        <mvc:interceptor>
            <!--拦截的,/*只拦截一层目录，/**所有层-->
            <mvc:mapping path="/**"/>
            <!--不拦截的-->
            <mvc:exclude-mapping path="/"/>
            <!--拦截器对象名-->
            <ref bean="firstInterceptor"></ref>
        </mvc:interceptor>
    </mvc:interceptors>
<!-- 
	以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求
-->
```

拦截器的类

```java
@Component//交给springmvc创建对象
public class FirstInterceptor  implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("preHandle...");
        return true;//返回true表示放行
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle...");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("afterCompletion...");
    }
}
```

- 2、拦截器的三个抽象方法

  SpringMVC中的拦截器有三个抽象方法：

  preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法

  postHandle：控制器方法执行之后执行postHandle()

  afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()

  源码

```java
//DispatcherServlet.java中
try{	
    //preHandle
	if (!mappedHandler.applyPreHandle(processedRequest, response)) {
         return;
     }
    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
    if (asyncManager.isConcurrentHandlingStarted()) {
         return;
    }
    this.applyDefaultViewName(processedRequest, mv);
    	//postHandle
         mappedHandler.applyPostHandle(processedRequest, response, mv);
    }

catch (Exception var20) {
         dispatchException = var20;
    } 
catch (Throwable var21) {
         dispatchException = new NestedServletException("Handler dispatch failed", var21);
    }

this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);

//afterComplation在this.processDispatchResult()方法中
  if (mappedHandler != null) {
      mappedHandler.triggerAfterCompletion(request, response, (Exception)null);
  }
  
```

- 3、多个拦截器的执行顺序

  a>若每个拦截器的preHandle()都返回true

  此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：上下关系

  preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行

```java
preHandle1();
preHandle2();
ha.handle();//目标方法
postHandle2();
postHandle1();
afterComplation2();
afterComplation1();
```

​	b>若某个拦截器的preHandle()返回了false

​	preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前（配置上下顺序）的拦截器的afterComplation()会执行（返回false的那个不会

### 异常处理器

- 1、基于配置的异常处理

  SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver

  HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver

  SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：

```xml
<bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
    <property name="exceptionMappings">
        <props>
        	<!--
        		properties的键表示处理器方法执行过程中出现的异常
        		properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面
        	-->
            <prop key="java.lang.ArithmeticException">error</prop>
        </props>
    </property>
    <!--
    	exceptionAttribute属性设置一个属性名，将出现的异常信息存在请求域
  		可通过<p th:text="${ex}"></p>在页面展示
			java.lang.ArithmeticException: / by zero
    -->
    <property name="exceptionAttribute" value="ex"></property>
</bean>
```

- 2、基于注解的异常处理

```java
//@ControllerAdvice将当前类标识为异常处理的组件
@ControllerAdvice
public class ExceptionController {

    //@ExceptionHandler用于设置所标识方法处理的异常
    @ExceptionHandler({ArithmeticException.class,NullPointerException.class})
    //ex表示当前请求处理中出现的异常对象
    public String handleArithmeticException(Exception ex, Model model){
        model.addAttribute("ex", ex);//放入请求域
        return "error";
    }

}
```

# ==Spring其他==

## ==springboot==

### 依赖

```xml
<!--定义了开发中常用的依赖的版本号-->
  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.3.12.RELEASE</version>
  </parent>

<dependencies>
	<dependency><!--springmvc-->
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-web</artifactId>
	</dependency>
</dependencies>
```

### 打包部署

在pom.xml添加

```xml
<packaging>jar</packaging>
<build>
    <!--记得不要其他的组件就行了-->
	<plugins>
		<plugin>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-maven-plugin</artifactId>
		</plugin>
	</plugins>
</build>
```

在IDEA的Maven插件上点击运行 clean 、package，把helloworld工程项目的打包成jar包，

打包好的jar包被生成在helloworld工程项目的target文件夹内。

内置了tomcat

用cmd运行`java -jar boot-01-helloworld-1.0-SNAPSHOT.jar`，既可以运行helloworld工程项目。

将jar包直接在目标服务器执行即可。

### 自动配置特性


- 自动配好Tomcat
  - 引入Tomcat依赖。
  - 配置Tomcat

```xml
spring-boot-starter-web-.中
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-tomcat</artifactId>
	<version>2.3.4.RELEASE</version>
	<scope>compile</scope>
</dependency>
```

- 自动配好SpringMVC
  - 引入SpringMVC全套组件
  - 自动配好SpringMVC常用组件（功能）

- 自动配好Web常见功能，如：字符编码问题
  - SpringBoot帮我们配置好了所有web开发的常见场景

```java
public static void main(String[] args) {
    //1、返回值是IOC容器
    ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

    //2、查看容器里面的组件
    String[] names = run.getBeanDefinitionNames();
    for (String name : names) {
        System.out.println(name);
    }
}
```

- 默认的包结构
  - 主程序@SpringBootApplication所在包及其下面的所有子包里面注解的组件都会被默认扫描进来
  - 想要改变扫描路径（当前目录及其所有子目录

```java
@SpringBootApplication(scanBasePackages="demo")
或者
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan("demo")
```

- 各种配置拥有默认值
  - 默认配置最终都是映射到某个类上的属性，如：`MultipartProperties`.java
  - 配置文件的值最终会绑定每个类上，这个类会在容器中创建对象

- 按需加载所有自动配置项
  - 非常多的starter
  - 引入了哪些场景这个场景的自动配置才会开启
  - SpringBoot所有的自动配置功能都在 spring-boot-autoconfigure 包里面
- ......

### @Configuration

- 基本使用
  - Full模式与Lite模式
  - 示例

```java
/**
 * 1、配置类里面可使用@Bean标注在方法上给容器注册组件，默认也是单实例的
 * 2、配置类本身也是组件
 * 3、proxyBeanMethods：代理bean的方法
 *    Full(proxyBeanMethods = true)（保证每个@Bean方法被调用多少次返回的组件都是单实例的）（默认），拿到的对象是代理对象
 *    Lite(proxyBeanMethods = false)（每个@Bean方法被调用多少次返回的组件都是新创建的），每各对象类型都是类的全限定名
 */
@Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件
public class MyConfig {

    /**
     * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象
     * @return
     */
    @Bean //给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例
    //组件名默认是方法名
    public User user01(){
        User zhangsan = new User("zhangsan", 18);
        //user组件依赖了Pet组件
        zhangsan.setPet(tomcatPet());
        return zhangsan;
    }

    @Bean("tom")//给组件取新名
    public Pet tomcatPet(){
        return new Pet("tomcat");
    }
}
```


@Configuration测试代码如下:

```java
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan("com.atguigu.boot")
public class MainApplication {

    public static void main(String[] args) {
    //1、返回我们IOC容器
        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

    //2、查看容器里面的组件
        String[] names = run.getBeanDefinitionNames();
        for (String name : names) {
            System.out.println(name);
        }

    //3、从容器中获取组件
        Pet tom01 = run.getBean("tom", Pet.class);
        Pet tom02 = run.getBean("tom", Pet.class);
        System.out.println("组件："+(tom01 == tom02));

    //4、proxyBeanMethods = true：com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca
        MyConfig bean = run.getBean(MyConfig.class);
        System.out.println(bean.getClass);

    //如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。
        //保持组件单实例
        User user = bean.user01();
        User user1 = bean.user01();
        System.out.println(user == user1);

        User user01 = run.getBean("user01", User.class);
        Pet tom = run.getBean("tom", Pet.class);

        System.out.println("用户的宠物："+(user01.getPet() == tom));
    }
}
```

- 最佳实战

  - 配置 类组件之间**无依赖关系**用Lite模式加速容器启动过程，减少判断
    - 不会在容器中 检查是否存在，速度快点
  - 配置 类组件之间**有依赖关系**，方法会被调用得到之前单实例组件，用Full模式（默认）
    - 会检查组件在容器是否存在

  ```java
  @Configuration(proxyBeanMethods = true)
  public class MyConfig {
      @Bean
      public User user01(){
          //User组件依赖Pet
          return new User("zhuxi",32,tomcat01());
      }
  
      @Bean
      public Pet tomcat01(){
          return new Pet("quyuan");
      }
  }
  user01.getPet() == tom//为true，说明容器中的Pet组件正是User依赖的
      
  若为@Configuration(proxyBeanMethods = false)且有组件依赖，那就不是同一个，因为调用一次生成一个新的组件。（好像idea都直接保红
  ```

> lite 英 [laɪt]   美 [laɪt]  
> adj. 低热量的，清淡的(light的一种拼写方法);类似…的劣质品

### @Import

导入组件,相当于@Configuration配置类中的@Bean导入组件

在组件的类上都可以

@Import({User.class, DBHelper.class})给容器中**自动创建出该类型的组件**、默认组件的名字就是全类名

```java
//
public @interface Import {
    Class<?>[] value();
}

//使用
@Import({User.class, DBHelper.class})
@Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件
public class MyConfig {
}
```

测试类：

```java
//1、返回我们IOC容器
ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

//...

//5、获取组件
String[] beanNamesForType = run.getBeanNamesForType(User.class);

for (String s : beanNamesForType) {
    System.out.println(s);
}

DBHelper bean1 = run.getBean(DBHelper.class);
System.out.println(bean1);
```

- 不同名，同类型的组件不是同一个，在@Configuration(proxyBeanMethods = true)下可以共存

````java
@Import({DBHelper.class,User.class})
@Configuration(proxyBeanMethods = true)
public class MyConfig {
    @Bean
    public User user01(){
        //User组件依赖Pet
        return new User("zhuxi",32,tomcat01());
    }
}
//2个组件名
user01
demo.bean.User
````

### @Conditional

- 决定标注的类或方法的是否进行组件注入**

![在这里插入图片描述](B:/我的坚果云/springboot2/image/20210205005453173.png)

条件

​    OnBean;存在该组件则中的Bean生效

​	OnClass:某个类

​	OnResource:类路径存在某个资源

​	OnWebApplication:应用是web应用时

用@ConditionalOnMissingBean举例说明

```java
@Configuration(proxyBeanMethods = false)

public class MyConfig {

    @ConditionalOnMissingBean(name = "tom")//容器没有tom名字的Bean时，user01方法的Bean才能生效。
    @Bean
    public User user01(){
        User zhangsan = new User("zhangsan", 18);
        zhangsan.setPet(tomcatPet());
        return zhangsan;
    }

    @Bean("tom22")
    public Pet tomcatPet(){
        return new Pet("tomcat");
    }
}

public static void main(String[] args) {
    //1、返回我们IOC容器
    ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

    //2、查看容器里面的组件
    String[] names = run.getBeanDefinitionNames();
    for (String name : names) {
        System.out.println(name);
    }

    boolean tom = run.containsBean("tom");
    System.out.println("容器中Tom组件："+tom);//false

    boolean user01 = run.containsBean("user01");
    System.out.println("容器中user01组件："+user01);//true

    boolean tom22 = run.containsBean("tom22");
    System.out.println("容器中tom22组件："+tom22);//true

}
```

### @ImportResource

导入Spring配置文件xml

比如，公司使用bean.xml文件生成配置bean，然而你为了省事，想继续复用bean.xml，@ImportResource粉墨登场。

bean.xml：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans ...">

    <bean id="haha" class="com.lun.boot.bean.User">
        <property name="name" value="zhangsan"></property>
        <property name="age" value="18"></property>
    </bean>

    <bean id="hehe" class="com.lun.boot.bean.Pet">
        <property name="name" value="tomcat"></property>
    </bean>
</beans>
```

使用方法：

```java
@ImportResource("classpath:beans.xml")
public class MyConfig {
...
}
```

测试类：

```java
public static void main(String[] args) {
    //1、返回我们IOC容器
    ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

	boolean haha = run.containsBean("haha");
	boolean hehe = run.containsBean("hehe");
	System.out.println("haha："+haha);//true
	System.out.println("hehe："+hehe);//true
}
```

### @ConfigurationProperties

配置绑定

如何使用Java读取到properties文件中的内容，并且把它封装到JavaBean中，以供随时使用

传统方法：

```java
public class getProperties {
     public static void main(String[] args) throws FileNotFoundException, IOException {
         Properties pps = new Properties();
         pps.load(new FileInputStream("a.properties"));
         Enumeration enum1 = pps.propertyNames();//得到配置文件的名字
         while(enum1.hasMoreElements()) {
             String strKey = (String) enum1.nextElement();
             String strValue = pps.getProperty(strKey);
             System.out.println(strKey + "=" + strValue);
             //封装到JavaBean。
         }
     }
 }
```

---

Spring Boot一种配置配置绑定：

@ConfigurationProperties + @Component

假设有配置文件application.properties

```properties
mycar.brand=BYD
mycar.price=100000
```

只有在容器中的组件，才会拥有SpringBoot提供的强大功能

```java
@Component//创建组件放入属性
@ConfigurationProperties(prefix = "mycar")//自动注入以mycar为前缀的属性
public class Car {
    private String brand;
    private Integer price;
...
}
//测试
    @Autowired
    private Car car;

    @RequestMapping("/hello")
    public String handle01(){
        return "Hello World";
    }
```

---

Spring Boot另一种配置配置绑定：

@EnableConfigurationProperties + @ConfigurationProperties

1. 开启Car配置绑定功能
2. 把这个Car这个组件自动注册到容器中
3. 应用：有些时候Car是引用了第三方的包，没有加@Compent


```java
@EnableConfigurationProperties(Car.class)
public class MyConfig {
...
}
```

```java
@Configuration()
@ConfigurationProperties(prefix = "mycar")
public class Car {
...
}
```

- 读取自定义的.properties

```java
@Component
@PropertySource("classpath:car.properties")    //加上类路径
@ConfigurationProperties(prefix = "car1")
```

### 配置文件-yaml的用法

​	同以前的properties用法

​	YAML 是 "YAML Ain't Markup Language"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是："Yet 	Another Markup Language"（仍是一种标记语言）。 

​	只能是application.yaml或者applicaion.yml才会被接管

​	非常适合用来做以数据为中心的配置文件。

- 基本语法
  - key: value；kv之间有空格
  - 大小写敏感
  - 使用缩进表示层级关系
  - 缩进不允许使用tab，只允许空格
  - 缩进的空格数不重要，只要相同层级的元素左对齐即可
  - '#'表示注释
  - 字符串无需加引号，如果要加，
    - 单引号''表示里面的转义字符不生效          'qi \n feng'      ->qi \\\n feng           输出         qi \n feng
    - 双引号""不转义                                           'qi \n feng'      ->qi \\n feng             输出         qi  换行 feng

- 数据类型

  - 字面量：单个的、不可再分的值。date、boolean、string、number、null

  ```yaml
  k: v
  ```

  - 对象：键值对的集合。map、hash、、object 

    ```yaml
    #行内写法：  
    
    k: {k1:v1,k2:v2,k3:v3}
    #或
    k: 
      k1: v1
      k2: v2
      k3: v3
    ```

  - 数组：一组按次序排列的值。array、list、set、queue

    ```yaml
    #行内写法：  
    
    k: [v1,v2,v3]
    
    #或者
    
    k:
     - v1
     - v2
     - v3
    ```

    

- 实例

```java
@Data
@ToString
@Component
@ConfigurationProperties(prefix="person")//还是通过前缀获取
public class Person {
    private String userName;
    private Boolean boss;
    private Date birth;
    private Integer age;
    private Pet pet;
    private String[] interests;
    private List<String> animal;
    private Map<String, Object> score;
    private Set<Double> salarys;
    private Map<String, List<Pet>> allPets;
}

@Data
public class Pet {
    private String name;
    private Double weight;
}
```

用yaml表示以上对象

```yaml
#成功的属性idea会提示成橙色，如果还是白色，看下是否少了空格
person:
  userName: zhangsan
  boss: false
  birth: 2019/12/12 20:12:33
  age: 18
  pet: 
    name: tomcat
    weight: 23.4
  interests: [篮球,游泳]
  animal: 
    - jerry
    - mario
  score:
    english: 
      first: 30
      second: 40
      third: 50
    math: [131,140,148]
    chinese: {first: 128,second: 136}
  salarys: [3999,4999.98,5999.99]
  allPets:
    sick:
      - {name: tom}
      - {name: jerry,weight: 47}
    health: [{name: mario,weight: 47}]
```

### 请求常用参数注解

注解：

- `@PathVariable` 路径变量（如通过rest风格的
- `@RequestHeader` 获取请求头
- `@RequestParam` 获取请求参数（指问号后的参数，url?a=1&b=2）
- `@CookieValue` 获取Cookie值
- `@RequestAttribute` 获取request域属性
- `@RequestBody` 获取请求体[POST]，若是表单提交，则请求体是表单内容
  - 只能有一个,因为只有一个请求体
  - 若只传递了接收实体的部分属性也行。
- `@MatrixVariable` 矩阵变量
- `@ModelAttribute`

自定义对象参数

- 可以自动类型转换和格式化，可以级联封装

使用用例：

```java
@RestController
public class ParameterTestController {


    //  car/2/owner/zhangsan
    @GetMapping("/car/{id}/owner/{username}")
    public Map<String,Object> getCar(@PathVariable("id") Integer id,
                                     @PathVariable("username") String name,
                                     @PathVariable Map<String,String> pv,
                                     @RequestHeader("User-Agent") String userAgent,
                                     @RequestHeader Map<String,String> header,
                                     @RequestParam("age") Integer age,
                                     @RequestParam("inters") List<String> inters,
                                     @RequestParam Map<String,String> params,
                                     @CookieValue("_ga") String _ga,
                                     @CookieValue("_ga") Cookie cookie){

        Map<String,Object> map = new HashMap<>();

//        map.put("id",id);
//        map.put("name",name);
//        map.put("pv",pv);
//        map.put("userAgent",userAgent);
//        map.put("headers",header);
        map.put("age",age);
        map.put("inters",inters);
        map.put("params",params);
        map.put("_ga",_ga);
        System.out.println(cookie.getName()+"===>"+cookie.getValue());
        return map;
    }


    @PostMapping("/save")
    public Map postMethod(@RequestBody String content){
        Map<String,Object> map = new HashMap<>();
        map.put("content",content);
        return map;
    }
}
```

### 拦截器

- 登录检查与静态资源放行

1. 编写一个拦截器实现`HandlerInterceptor`接口

2. 拦截器注册到容器中（实现`WebMvcConfigurer`的`addInterceptors()`）

3. 指定拦截规则（<span style="color:red;">注意</span>，如果是拦截所有，静态资源也会被拦截】

- emm，一般拦截的范围比放行的大不会出问题

编写一个实现`HandlerInterceptor`接口的拦截器：

```java
@Slf4j
public class LoginInterceptor implements HandlerInterceptor {

    /**
     * 目标方法执行之前
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

        String requestURI = request.getRequestURI();
        log.info("preHandle拦截的请求路径是{}",requestURI);

        //登录检查逻辑
        HttpSession session = request.getSession();

        Object loginUser = session.getAttribute("loginUser");

        if(loginUser != null){
            //放行
            return true;
        }

        //拦截住。未登录。跳转到登录页
        request.setAttribute("msg","请先登录");
//        re.sendRedirect("/");
        request.getRequestDispatcher("/").forward(request,response);
        return false;
    }

    /**
     * 目标方法执行完成以后
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        log.info("postHandle执行{}",modelAndView);
    }

    /**
     * 页面渲染以后
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        log.info("afterCompletion执行异常{}",ex);
    }
}
```



拦截器注册到容器中 && 指定拦截规则：

若是把静态资源如.css拦截了,则页面中所有引用的css样式都会失效

```java
@Configuration
public class AdminWebConfig implements WebMvcConfigurer{
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoginInterceptor())//拦截器注册到容器中
                .addPathPatterns("/**")  //所有请求都被拦截包括静态资源
                .excludePathPatterns("/","/login","/css/**","/fonts/**","/images/**",
                        "/js/**","/aa/**"); //放行的请求和相应目录下的静态资源
}
```

### 文件上传

- 好！放弃这个，springboot中总是找不到参数注入。。下次自己再开个项目测试下

- 页面代码`/static/form/form_layouts.html`

```html
<form role="form" th:action="@{/upload}" method="post" enctype="multipart/form-data">
    <div class="form-group">
        <label for="exampleInputEmail1">邮箱</label>
        <input type="email" name="email" class="form-control" id="exampleInputEmail1" placeholder="Enter email">
    </div>
    
    <div class="form-group">
        <label for="exampleInputPassword1">名字</label>
        <input type="text" name="username" class="form-control" id="exampleInputPassword1" placeholder="Password">
    </div>
    
    <div class="form-group">
        <label for="exampleInputFile">头像</label>
        <input type="file" name="headerImg" id="exampleInputFile">
    </div>
    
    <div class="form-group">
        <label for="exampleInputFile">生活照(多文件)</label>
        <input type="file" name="photos" multiple>
    </div>
    
    <div class="checkbox">
        <label>
            <input type="checkbox"> Check me out
        </label>
    </div>
    <button type="submit" class="btn btn-primary">提交</button>
</form>
```

- 控制层代码

```java
//用MultipartFile封装文件
@Slf4j
@Controller
public class FormTestController {

    @GetMapping("/form_layouts")
    public String form_layouts(){
        return "form/form_layouts";
    }

    @PostMapping("/upload")
    public String upload(@RequestParam("email") String email,
                         @RequestParam("username") String username,
                         @RequestPart("headerImg") MultipartFile headerImg,
                         @RequestPart("photos") MultipartFile[] photos) throws IOException {

        log.info("上传的信息：email={}，username={}，headerImg={}，photos={}",
                 email,username,headerImg.getSize(),photos.length);

        if(!headerImg.isEmpty()){
            //保存到文件服务器，OSS服务器
            String originalFilename = headerImg.getOriginalFilename();
            headerImg.transferTo(new File("H:\\cache\\"+originalFilename));
        }

        if(photos.length > 0){
            for (MultipartFile photo : photos) {
                if(!photo.isEmpty()){
                    String originalFilename = photo.getOriginalFilename();
                    photo.transferTo(new File("H:\\cache\\"+originalFilename));
                }
            }
        }


        return "main";
    }
}
```



文件上传相关的配置类：

- `org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration`
- `org.springframework.boot.autoconfigure.web.servlet.MultipartProperties`

文件大小相关配置项：

```properties
spring.servlet.multipart.max-file-size=10MB    //单个默认最大1m
spring.servlet.multipart.max-request-size=100MB   //默认总的最大不能大于10（整个请求
```

### Druid

官网介绍：https://github.com/alibaba/druid/wiki/Druid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BB%8B%E7%BB%8D

Druid连接池为监控而生，内置强大的监控功能，监控特性不影响性能。功能强大，能防SQL注入，内置Loging能诊断Hack应用行为

监控页界面地址如：http://localhost:端口/druid/sql.html

**引入依赖**：

```xml
<!--数据源其他的都不用了-->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.1.17</version>
</dependency>
```

**配置示例**：

```yaml
#以下只是示例，很多已经自动配置好了
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/db_account
    username: root
    password: 123456
    driver-class-name: com.mysql.cj.jdbc.Driver

    druid:
      aop-patterns: com.atguigu.admin.*  #监控SpringBean
      filters: stat,wall     # 底层开启功能，stat（sql监控），wall（防火墙）

      stat-view-servlet:   # 配置监控页功能
        enabled: true
        login-username: admin
        login-password: admin
        resetEnable: false

      web-stat-filter:  # 监控web
        enabled: true
        urlPattern: /*
        exclusions: '*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*'


      filter:
        stat:    # 对上面filters里面的stat的详细配置
          slow-sql-millis: 1000
          logSlowSql: true
          enabled: true
        wall:
          enabled: true
          config:
            drop-table-allow: false
```



### 单元测试

- 官网：https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations
- 依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
```

- 使用

```java
@SpringBootTest              //Junit5要标这个注解
class SpringBootApplicationTests {

    @Autowired
    private Component component;
    
    @Test
    //@Transactional 标注后连接数据库有回滚功能
    public void contextLoads() {
		Assertions.assertEquals(5, component.getFive());
    }
}
```

- 常用注解（标在方法上
  - **@Test**：表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试
  - **@ParameterizedTest**：表示方法是参数化测试。
  - **@RepeatedTest(n)**：表示方法重复执行的次数。
  - **@DisplayName**：为测试类或者测试方法设置展示名称。
  - **@BeforeEach**：表示在**每个**单元测试**之前**执行。
  - **@AfterEach**：表示在**每个**单元测试**之后**执行。
  - **@BeforeAll**：表示在**所有**单元测试**之前**执行。
  - **@AfterAll**：表示在**所有**单元测试**之后**执行。
  - **@Tag**：表示单元测试类别，类似于JUnit4中的@Categories。
  - **@Disabled**：表示测试类或测试方法不执行，类似于JUnit4中的@Ignore。
  - **@Timeout**：表示测试方法运行如果超过了指定时间将会返回错误。
  - **@ExtendWith**：为测试类或测试方法提供扩展类引用。

### 断言机制测试

断言Assertion是测试方法中的核心部分，用来对测试需要满足的条件进行验证。这些断言方法都是org.junit.jupiter.api.Assertions的静态方法。检查业务逻辑返回的数据是否合理。所有的测试运行结束以后，会有一个详细的测试报告。

JUnit 5 内置的断言可以分成如下几个类别：

- 简单断言

用来对单个值进行简单的验证。如：

| 方法            | 说明                                 |
| --------------- | ------------------------------------ |
| assertEquals    | 判断两个对象或两个原始类型是否相等   |
| assertNotEquals | 判断两个对象或两个原始类型是否不相等 |
| assertSame      | 判断两个对象引用是否指向同一个对象   |
| assertNotSame   | 判断两个对象引用是否指向不同的对象   |
| assertTrue      | 判断给定的布尔值是否为 true          |
| assertFalse     | 判断给定的布尔值是否为 false         |
| assertNull      | 判断给定的对象引用是否为 null        |
| assertNotNull   | 判断给定的对象引用是否不为 null      |

```java
@Test
@DisplayName("simple assertion")
public void simple() {
     assertEquals(3, 1 + 2, "simple math");
     assertNotEquals(3, 1 + 1);

     assertNotSame(new Object(), new Object());
     Object obj = new Object();
     assertSame(obj, obj);

     assertFalse(1 > 2);
     assertTrue(1 < 2);

     assertNull(null);
     assertNotNull(new Object());
}
//断言失败后，方法不会往下执行
```

- 数组断言

通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等。

```java
@Test
@DisplayName("array assertion")
public void array() {
	assertArrayEquals(new int[]{1, 2}, new int[] {1, 2});
}
```

- 组合断言

`assertAll()`方法接受多个 `org.junit.jupiter.api.Executable` 函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言。

```java
@Test
@DisplayName("assert all")   //所有成功才算成功
public void all() {
 assertAll("Math",
    () -> assertEquals(2, 1 + 1),
    () -> assertTrue(1 > 0)
 );
}
```

- 异常断言

在JUnit4时期，想要测试方法的异常情况时，需要用`@Rule`注解的`ExpectedException`变量还是比较麻烦的。而JUnit5提供了一种新的断言方式`Assertions.assertThrows()`，配合函数式编程就可以进行使用。

```java
@Test
@DisplayName("异常测试")    //抛出对应异常才算成功
public void exceptionTest() {
    ArithmeticException exception = Assertions.assertThrows(
           //扔出断言异常
            ArithmeticException.class, () -> System.out.println(1 % 0));
}
```

- 超时断言

JUnit5还提供了Assertions.assertTimeout()为测试方法设置了超时时间。

```java
@Test
@DisplayName("超时测试")
public void timeoutTest() {
    //如果测试方法时间超过1s将会异常
    Assertions.assertTimeout(Duration.ofMillis(1000), () -> Thread.sleep(500));
}
```

- 快速失败

通过 fail 方法直接使得测试失败。

```java
@Test
@DisplayName("fail")
public void shouldFail() {
	fail("This should fail");
}
```

### 参数化测试

官网：https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests

参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。

利用@ValueSource等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。

利用**@ValueSource**等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。

- **@ValueSource**: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型
- **@NullSource**: 表示为参数化测试提供一个null的入参
- **@EnumSource**: 表示为参数化测试提供一个枚举入参
- **@CsvFileSource**：表示读取指定CSV文件内容作为参数化测试入参
- **@MethodSource**：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)

当然如果参数化测试仅仅只能做到指定普通的入参还达不到让我觉得惊艳的地步。让我真正感到他的强大之处的地方在于他可以支持外部的各类入参。如:CSV,YML,JSON 文件甚至方法的返回值也可以作为入参。只需要去实现**`ArgumentsProvider`**接口，任何外部文件都可以作为它的入参。

```java
@ParameterizedTest
@ValueSource(strings = {"one", "two", "three"})
@DisplayName("参数化测试1")
public void parameterizedTest1(String string) {
    System.out.println(string);
    Assertions.assertTrue(StringUtils.isNotBlank(string));
}


@ParameterizedTest
@MethodSource("method")    //指定方法名
@DisplayName("方法来源参数")
public void testWithExplicitLocalMethodSource(String name) {
    System.out.println(name);
    Assertions.assertNotNull(name);
}

static Stream<String> method() {//返回不一定是流，String[]也可以
    return Stream.of("apple", "banana");
}
```

### SpringBoot Actuator

- 依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

- 访问`http://localhost:8080/actuator/**`。
- 暴露所有监控信息为HTTP。

```yaml
management:
  endpoints:
    enabled-by-default: true #暴露所有端点信息
    web:
      exposure:
        include: '*'  #以web方式暴露
```

- 测试例子
  - http://localhost:8080/actuator/beans
  - http://localhost:8080/actuator/configprops
  - http://localhost:8080/actuator/metrics
  - http://localhost:8080/actuator/metrics/jvm.gc.pause
  - http://localhost:8080/actuator/metrics/endpointName/detailPath

- 定制Endpoint看原文

### 环境切换

为了方便多环境适配，Spring Boot简化了profile功能。

- 默认配置文件`application.yaml`任何时候都会加载。
- 指定环境配置文件`application-{env}.yaml`，`env`通常替代为`test`，
- 激活指定环境
  - 配置文件激活：`spring.profiles.active=prod`
  - 命令行激活：`java -jar xxx.jar --spring.profiles.active=prod  --person.name=haha`（修改配置文件的任意值，**命令行优先**）
- 默认配置与环境配置同时生效
- 同名配置项，profile配置优先

- @Profile条件装配功能

```java
@Data
@Component
@ConfigurationProperties("person")//在配置文件中配置
public class Person{
    private String name;
    private Integer age;
}
```

application.properties

```yaml
person: 
  name: lun
  age: 8
```

---

```java
public interface Person {

   String getName();
   Integer getAge();

}

@Profile("test")//加载application-test.yaml里的
@Component
@ConfigurationProperties("person")
@Data
public class Worker implements Person {

    private String name;
    private Integer age;
}

@Profile(value = {"prod","default"})//加载application-prod.yaml里的
@Component
@ConfigurationProperties("person")
@Data
public class Boss implements Person {

    private String name;
    private Integer age;
}
```



application-test.yaml

```yaml
person:
  name: test-张三

server:
  port: 7000
```



application-prod.yaml

```yaml
person:
  name: prod-张三

server:
  port: 8000
```



application.properties（或者在application.yaml

```properties
# 激活prod配置文件
spring.profiles.active=prod
```

```java
@Autowired
private Person person;

@GetMapping("/")
public String hello(){
    //激活了prod，则返回Boss；激活了test，则返回Worker
    return person.getClass().toString();
}
```

---



@Profile还可以修饰在方法上：

```java
class Color {
}

@Configuration
public class MyConfig {

    @Profile("prod")
    @Bean
    public Color red(){
        return new Color();
    }

    @Profile("test")
    @Bean
    public Color green(){
        return new Color();
    }
}
```

---

可以激活一组：

```properties
spring.profiles.active=production

spring.profiles.group.production[0]=proddb
spring.profiles.group.production[1]=prodmq
```

### 自定义starter

- 目标：创建`HelloService`的自定义starter。

- 创建两个工程，分别命名为`hello-spring-boot-starter`（普通Maven工程），`hello-spring-boot-starter-autoconfigure`（需用用到Spring Initializr创建的Maven工程）。

- `hello-spring-boot-starter`无需编写什么代码，只需让该工程引入`hello-spring-boot-starter-autoconfigure`依赖：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.lun</groupId>
    <artifactId>hello-spring-boot-starter</artifactId>
    <version>1.0.0-SNAPSHOT</version>

    <dependencies>
        <dependency>
            <groupId>com.lun</groupId>
            <artifactId>hello-spring-boot-starter-autoconfigure</artifactId>
            <version>1.0.0-SNAPSHOT</version>
        </dependency>
    </dependencies>

</project>
```

- `hello-spring-boot-starter-autoconfigure`的pom.xml如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.4.2</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.lun</groupId>
	<artifactId>hello-spring-boot-starter-autoconfigure</artifactId>
	<version>1.0.0-SNAPSHOT</version>
	<name>hello-spring-boot-starter-autoconfigure</name>
	<description>Demo project for Spring Boot</description>
	<properties>
		<java.version>1.8</java.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter</artifactId>
		</dependency>
	</dependencies>
</project>
```

- 创建4个文件：
  - `com/lun/hello/auto/HelloServiceAutoConfiguration`
  - `com/lun/hello/bean/HelloProperties`
  - `com/lun/hello/service/HelloService`
  - `src/main/resources/META-INF/spring.factories`

```java
import com.lun.hello.bean.HelloProperties;
import com.lun.hello.service.HelloService;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConditionalOnMissingBean(HelloService.class)
@EnableConfigurationProperties(HelloProperties.class)//默认HelloProperties放在容器中
public class HelloServiceAutoConfiguration {

    @Bean
    public HelloService helloService(){
        return new HelloService();
    }

}
```

```java
import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties("hello")
public class HelloProperties {
    private String prefix;
    private String suffix;

    public String getPrefix() {
        return prefix;
    }

    public void setPrefix(String prefix) {
        this.prefix = prefix;
    }

    public String getSuffix() {
        return suffix;
    }

    public void setSuffix(String suffix) {
        this.suffix = suffix;
    }
}

```

```java
import com.lun.hello.bean.HelloProperties;
import org.springframework.beans.factory.annotation.Autowired;


/**
 * 默认不要放在容器中
 */
public class HelloService {

    @Autowired
    private HelloProperties helloProperties;

    public String sayHello(String userName){
        return helloProperties.getPrefix() + ": " + userName + " > " + helloProperties.getSuffix();
    }
}
```

```properties
# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.lun.hello.auto.HelloServiceAutoConfiguration
```

- 用maven插件，将两工程install到本地。

- 接下来，测试使用自定义starter，用Spring Initializr创建名为`hello-spring-boot-starter-test`工程，引入`hello-spring-boot-starter`依赖，其pom.xml如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.2</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.lun</groupId>
    <artifactId>hello-spring-boot-starter-test</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <name>hello-spring-boot-starter-test</name>
    <description>Demo project for Spring Boot</description>
    <properties>
        <java.version>1.8</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- 引入`hello-spring-boot-starter`依赖 -->
        <dependency>
            <groupId>com.lun</groupId>
            <artifactId>hello-spring-boot-starter</artifactId>
            <version>1.0.0-SNAPSHOT</version>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```

- 添加配置文件`application.properties`：

```properties
hello.prefix=hello
hello.suffix=666
```

- 添加单元测试类：

```java
import com.lun.hello.service.HelloService;//来自自定义starter
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class HelloSpringBootStarterTestApplicationTests {

    @Autowired
    private HelloService helloService;

    @Test
    void contextLoads() {
        // System.out.println(helloService.sayHello("lun"));
        Assertions.assertEquals("hello: lun > 666", helloService.sayHello("lun"));
    }

}
```

